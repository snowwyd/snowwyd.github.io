---
layout: default
title: "Docker"
permalink: /1. Погружение в основы/Docker/
---

## Что такое Docker и зачем он нужен?
---
Представь, что твое приложение — это мебель из IKEA. Docker — это **коробка**, в которой лежат все детали, инструменты и инструкция по сборке. Где бы ты ни открыл эту коробку — в любой стране, на любом компьютере — результат будет одинаковым.

**Проблема, которую решает Docker:** "У меня на компьютере работает, а на сервере — нет!"

## Основные понятия
---
### Образ (Image)
**Образ** — это "шаблон" или "чертеж" приложения. Он содержит:
- Код твоего приложения
- Все зависимости (библиотеки, фреймворки)
- Системные настройки
- Инструкции по запуску

Можно сравнить с **установочным файлом Windows** — он содержит всё необходимое для установки системы.

### Контейнер (Container)
**Контейнер** — это запущенный экземпляр образа. Если образ — это класс в программировании, то контейнер — объект этого класса.

Простая аналогия:
- **Образ** = исполняемый файл (`app.exe`)
- **Контейнер** = запущенный процесс этого файла

## Зачем это Go-разработчику?
---
1. **Изоляция зависимостей** — не важно, какая версия Go установлена на системе
2. **Идентичные окружения** — разработка, тестирование, продакшен
3. **Простота развертывания** — один образ работает везде
4. **Масштабируемость** — легко запустить несколько копий сервиса

## Простой Dockerfile для Go приложения

Создай файл `Dockerfile` в корне проекта:

```dockerfile
# Используем официальный образ Go
FROM golang:1.21-alpine

# Устанавливаем рабочую директорию внутри контейнера
WORKDIR /app

# Копируем файлы зависимостей
COPY go.mod go.sum ./

# Скачиваем зависимости
RUN go mod download

# Копируем исходный код
COPY . .

# Собираем приложение
RUN go build -o main ./cmd/api

# Открываем порт, который слушает приложение
EXPOSE 8080

# Команда для запуска приложения
CMD ["./main"]
```

### Сборка и запуск:
```bash
# Собираем образ
docker build -t my-go-app .

# Запускаем контейнер
docker run -p 8080:8080 my-go-app
```

## Проблема: размер образа
---
Проверим размер нашего образа:
```bash
docker images my-go-app
```
Мы увидим около **800MB-1GB**! Почему? Потому что в образе остались:
- Компилятор Go
- Исходный код
- Промежуточные файлы сборки

А нам нужен только **бинарный файл**!

## Решение: Multistage сборка
---
Multistage сборка — это создание образа в несколько этапов, где на каждом этапе можно использовать разные базовые образы и копировать только нужные артефакты.

### Улучшенный Dockerfile с multistage:

```dockerfile
# Этап 1: Сборка (Builder)
FROM golang:1.21-alpine AS builder

WORKDIR /app

# Копируем файлы зависимостей
COPY go.mod go.sum ./
RUN go mod download

# Копируем исходный код
COPY . .

# Собираем статический бинарник
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main ./cmd/api

# Этап 2: Запуск (Runtime)
FROM alpine:latest

# Устанавливаем безопасность: создаем непривилегированного пользователя
RUN addgroup -S appgroup && adduser -S appuser -G appgroup

# Устанавливаем зависимости для безопасной работы
RUN apk --no-cache add ca-certificates

WORKDIR /root/

# Копируем бинарник из этапа сборки
COPY --from=builder /app/main .

# Переключаемся на непривилегированного пользователя
USER appuser

# Открываем порт
EXPOSE 8080

# Запускаем приложение
CMD ["./main"]
```

### Что изменилось?
- **Этап 1**: Собираем приложение в полном окружении Go
- **Этап 2**: Создаем минимальный образ только с бинарником
- **Безопасность**: Запускаем от непривилегированного пользователя

Теперь размер образа: **всего 10-20MB**!

## Docker Compose для разработки

Создай `docker-compose.yml` для локальной разработки:

```yaml
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "8080:8080"
    environment:
      - DATABASE_URL=postgres://user:pass@db:5432/app
    depends_on:
      - db
    volumes:
      - .:/app  # Монтируем код для hot-reload
      - /app/go/pkg/mod  # Кэш зависимостей

  db:
    image: postgres:15
    environment:
      POSTGRES_DB: app
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

## Полезные команды для работы с Docker
---
```bash
# Сборка с кэшем
docker build -t my-app .

# Просмотр образов
docker images

# Запуск контейнера
docker run -p 8080:8080 my-app

# Просмотр запущенных контейнеров
docker ps

# Остановка контейнера
docker stop <container_id>

# Просмотр логов
docker logs <container_id>

# Вход в контейнер (для отладки)
docker exec -it <container_id> /bin/sh

# Очистка неиспользуемых образов
docker system prune
```

## Best Practices для Go разработчиков
---
1. **Используй .dockerignore**
   ```gitignore
   .git
   Dockerfile
   README.md
   vendor/
   *.test
   .env
   ```

2. **Многоступенчатая сборка** — всегда для production
3. **Статическая линковка** — `CGO_ENABLED=0`
4. **Минимальные базовые образы** — alpine или distroless
5. **Непривилегированный пользователь** — безопасность прежде всего
6. **Одна задача на контейнер** — микросервисный подход

---

**[← Назад к Backend](../Backend/)**