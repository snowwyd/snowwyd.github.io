---
layout: default
title: "Связывание микросервисов"
permalink: /1. Погружение в основы/Связывание микросервисов/
---

*В этом разделе будет небольшая справка с примером, как подсоединить один микросервис к другому. Тебе это нужно для одного задания из главы. А также это критически важный навык программиста на Go*


## Концепция связи "сервис-сервис"
---
В микросервисной архитектуре сервисы общаются друг с другом как **равноправные клиенты**. Твой сервис может быть одновременно:
- **Сервером** для одних сервисов
- **Клиентом** для других сервисов

## Практический пример: Сервис Заказов вызывает сервис Пользователей
---
Представим, что у нас есть:
- **Сервис Пользователей (User Service)** - управляет пользователями
- **Сервис Заказов (Order Service)** - управляет заказами, но ему нужно проверять данные пользователя

### Шаг 1: Дорабатываем сервис Пользователей

Добавляем метод для проверки существования пользователя в `user_service.proto`:

```protobuf
syntax = "proto3";

package user;
option go_package = "./user";

service UserService {
  rpc GetUser(UserRequest) returns (UserResponse) {}
  rpc ValidateUser(ValidateUserRequest) returns (ValidateUserResponse) {}
}

message UserRequest {
  string user_id = 1;
}

message UserResponse {
  string user_id = 1;
  string name = 2;
  string email = 3;
  bool active = 4;
}

message ValidateUserRequest {
  string user_id = 1;
}

message ValidateUserResponse {
  bool valid = 1;
  string user_name = 2;
  string error_message = 3;
}
```

### Шаг 2: Реализуем сервер User Service

```go
package main

import (
	"context"
	"log"
	"net"

	"your-project/user-service/proto/user"
	"google.golang.org/grpc"
)

type userServer struct {
	user.UnimplementedUserServiceServer
}

// База данных в памяти для примера
var users = map[string]*user.UserResponse{
	"user-123": {
		UserId: "user-123",
		Name:   "Иван Иванов",
		Email:  "ivan@example.com",
		Active: true,
	},
	"user-456": {
		UserId: "user-456", 
		Name:   "Мария Петрова",
		Email:  "maria@example.com",
		Active: true,
	},
}

func (s *userServer) GetUser(ctx context.Context, req *user.UserRequest) (*user.UserResponse, error) {
	log.Printf("Получен запрос на пользователя: %s", req.UserId)
	
	if user, exists := users[req.UserId]; exists {
		return user, nil
	}
	
	return nil, status.Error(codes.NotFound, "Пользователь не найден")
}

func (s *userServer) ValidateUser(ctx context.Context, req *user.ValidateUserRequest) (*user.ValidateUserResponse, error) {
	log.Printf("Валидация пользователя: %s", req.UserId)
	
	if user, exists := users[req.UserId]; exists && user.Active {
		return &user.ValidateUserResponse{
			Valid:     true,
			UserName:  user.Name,
		}, nil
	}
	
	return &user.ValidateUserResponse{
		Valid:        false,
		ErrorMessage: "Пользователь не найден или не активен",
	}, nil
}

func main() {
	lis, err := net.Listen("tcp", ":50051")
	if err != nil {
		log.Fatalf("Ошибка: %v", err)
	}
	
	s := grpc.NewServer()
	user.RegisterUserServiceServer(s, &userServer{})
	
	log.Println("User Service запущен на :50051")
	s.Serve(lis)
}
```

### Шаг 3: Создаем Order Service как клиент

Сначала создаем `.proto` для Order Service:

```protobuf
syntax = "proto3";

package order;
option go_package = "./order";

service OrderService {
  rpc CreateOrder(CreateOrderRequest) returns (CreateOrderResponse) {}
}

message CreateOrderRequest {
  string order_id = 1;
  string user_id = 2;
  repeated OrderItem items = 3;
}

message OrderItem {
  string product_id = 1;
  int32 quantity = 2;
  double price = 3;
}

message CreateOrderResponse {
  string order_id = 1;
  string status = 2;
  string user_name = 3;
  double total_amount = 4;
  string error_message = 5;
}
```

### Шаг 4: Реализуем Order Service с вызовом User Service

```go
package main

import (
	"context"
	"log"
	"net"
	"time"

	"your-project/order-service/proto/order"
	"your-project/user-service/proto/user" // Импортируем proto из user service

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

type orderServer struct {
	order.UnimplementedOrderServiceServer
	userClient user.UserServiceClient // Клиент для User Service
}

func NewOrderServer() *orderServer {
	// Создаем соединение с User Service
	conn, err := grpc.Dial("localhost:50051", 
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithTimeout(5*time.Second))
	
	if err != nil {
		log.Fatalf("Не удалось подключиться к User Service: %v", err)
	}
	
	return &orderServer{
		userClient: user.NewUserServiceClient(conn),
	}
}

func (s *orderServer) CreateOrder(ctx context.Context, req *order.CreateOrderRequest) (*order.CreateOrderResponse, error) {
	log.Printf("Создание заказа %s для пользователя %s", req.OrderId, req.UserId)
	
	// Валидируем пользователя через User Service
	validateReq := &user.ValidateUserRequest{UserId: req.UserId}
	validateResp, err := s.userClient.ValidateUser(ctx, validateReq)
	
	if err != nil {
		return &order.CreateOrderResponse{
			OrderId:      req.OrderId,
			Status:       "ERROR",
			ErrorMessage: "Ошибка валидации пользователя: " + err.Error(),
		}, nil
	}
	
	if !validateResp.Valid {
		return &order.CreateOrderResponse{
			OrderId:      req.OrderId,
			Status:       "ERROR", 
			ErrorMessage: validateResp.ErrorMessage,
		}, nil
	}
	
	// Рассчитываем общую сумму
	total := 0.0
	for _, item := range req.Items {
		total += item.Price * float64(item.Quantity)
	}
	
	// Создаем заказ (в реальном приложении здесь была бы запись в БД)
	return &order.CreateOrderResponse{
		OrderId:     req.OrderId,
		Status:      "CREATED",
		UserName:    validateResp.UserName,
		TotalAmount: total,
	}, nil
}

func main() {
	server := NewOrderServer()
	
	lis, err := net.Listen("tcp", ":50052")
	if err != nil {
		log.Fatalf("Ошибка: %v", err)
	}
	
	s := grpc.NewServer()
	order.RegisterOrderServiceServer(s, server)
	
	log.Println("Order Service запущен на :50052")
	s.Serve(lis)
}
```

## Конфигурация и управление соединениями
---
### Создание переиспользуемого клиента

```go
package client

import (
	"your-project/user-service/proto/user"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

type UserServiceClient struct {
	client user.UserServiceClient
	conn   *grpc.ClientConn
}

func NewUserServiceClient(address string) (*UserServiceClient, error) {
	conn, err := grpc.Dial(address,
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithTimeout(10*time.Second))
	
	if err != nil {
		return nil, err
	}
	
	return &UserServiceClient{
		client: user.NewUserServiceClient(conn),
		conn:   conn,
	}, nil
}

func (c *UserServiceClient) Close() {
	c.conn.Close()
}

func (c *UserServiceClient) ValidateUser(userID string) (bool, string, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	resp, err := c.client.ValidateUser(ctx, &user.ValidateUserRequest{UserId: userID})
	if err != nil {
		return false, "", err
	}
	
	return resp.Valid, resp.UserName, nil
}
```

## Запуск и тестирование связанных сервисов
---
### Docker Compose для локального запуска через контейнеры

```yaml
version: '3.8'
services:
  user-service:
    build: ./user-service
    ports:
      - "50051:50051"
    environment:
      - PORT=50051

  order-service:
    build: ./order-service  
    ports:
      - "50052:50052"
    environment:
      - USER_SERVICE_URL=user-service:50051
      - PORT=50052
    depends_on:
      - user-service
```

---

**[← Назад к Backend](../Backend/)**
