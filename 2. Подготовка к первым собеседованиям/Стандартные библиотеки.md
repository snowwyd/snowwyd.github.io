---
layout: default
title: Стандартная библиотека - важные пакеты
permalink: /interview-prep/go-deep-dive/stdlib/
---

# Цель
---
Go имеет богатую стандартную библиотеку. Ты должен знать, какие пакеты существуют, для чего они нужны, и как их эффективно использовать. Это сэкономит тебе время и избавит от написания велосипедов.

# Зачем это нужно на собеседовании?
---
Тебя спросят:
- Какие пакеты есть в стандартной библиотеке?
- Как использовать sync пакет?
- Чем atomic отличается от mutex?
- Как работать с временем в Go?
- Какие есть полезные пакеты для работы с данными?

Хороший разработчик знает стандартную библиотеку.

# Теория

### sync пакет
---
**sync** — пакет для синхронизации горутин.

#### WaitGroup (уже знаешь)
```go
var wg sync.WaitGroup
wg.Add(1)
go func() {
    defer wg.Done()
    // работа
}()
wg.Wait()
```

#### Mutex (мьютекс)
```go
var mu sync.Mutex
var counter int

// Защитить доступ к counter
mu.Lock()
counter++
mu.Unlock()

// Или с defer для автоматического разблокирования
mu.Lock()
defer mu.Unlock()
counter++
```

#### RWMutex (читать-писать мьютекс)
```go
var mu sync.RWMutex
var data map[string]string

// Много горутин могут читать одновременно
mu.RLock()
value := data["key"]
mu.RUnlock()

// Но только одна может писать
mu.Lock()
data["key"] = "value"
mu.Unlock()
```

#### Once (выполнить один раз)
```go
var once sync.Once
var instance *Singleton

func getInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{}
    })
    return instance
}

// getInstance() будет инициализировать только один раз
// даже если вызвать из разных горутин
```

#### Pool (переиспользование объектов)
```go
bufferPool := sync.Pool{
    New: func() interface{} {
        return make([]byte, 4096)
    },
}

// Получить из pool
buffer := bufferPool.Get().([]byte)

// Использовать
process(buffer)

// Вернуть в pool
bufferPool.Put(buffer)
```

### sync/atomic пакет
---
**atomic** — атомарные операции (безопасные без мьютекса).

```go
import "sync/atomic"

var counter int64

// Атомарно увеличить
atomic.AddInt64(&counter, 1)

// Атомарно получить
value := atomic.LoadInt64(&counter)

// Атомарно установить
atomic.StoreInt64(&counter, 100)

// Атомарно сравнить и обменять (CAS)
old := atomic.CompareAndSwapInt64(&counter, 100, 200)
```

**Когда использовать atomic вместо mutex?**
```go
// ❌ Для счётчика лучше atomic (быстрее)
var mu sync.Mutex
var counter int
mu.Lock()
counter++
mu.Unlock()

// ✅ Для счётчика лучше atomic (в 10 раз быстрее)
var counter int64
atomic.AddInt64(&counter, 1)
```

### time пакет
---
```go
import "time"

// Текущее время
now := time.Now()
fmt.Println(now)  // 2024-01-01 12:34:56.123456789 +0000 UTC

// Duration (длительность)
d := 5 * time.Second
time.Sleep(d)

// Таймеры
timer := time.NewTimer(1 * time.Second)
<-timer.C
fmt.Println("1 second passed")

// Tickers (повторяющиеся)
ticker := time.NewTicker(1 * time.Second)
for i := 0; i < 3; i++ {
    <-ticker.C
    fmt.Println("Tick")
}
ticker.Stop()

// Форматирование времени
t := time.Now()
fmt.Println(t.Format("2006-01-02"))  // 2024-01-01
fmt.Println(t.Format(time.RFC3339))  // 2024-01-01T12:34:56Z

// Парсинг времени
t, _ := time.Parse("2006-01-02", "2024-01-01")
```

### io пакет
---
```go
import "io"

// Reader интерфейс
type Reader interface {
    Read(p []byte) (n int, err error)
}

// Writer интерфейс
type Writer interface {
    Write(p []byte) (n int, err error)
}

// Copy: прочитать из src и написать в dst
io.Copy(dst, src)

// ReadAll: прочитать всё
data, _ := io.ReadAll(reader)

// Combine: несколько readers
combined := io.MultiReader(reader1, reader2)
```

### strings пакет
---
```go
import "strings"

s := "Hello, World!"

// Поиск
strings.Contains(s, "World")           // true
strings.Index(s, "World")              // 7
strings.Count(s, "l")                  // 3

// Преобразование
strings.ToLower(s)                     // "hello, world!"
strings.ToUpper(s)                     // "HELLO, WORLD!"
strings.TrimSpace("  hello  ")         // "hello"

// Замена
strings.ReplaceAll(s, "World", "Go")  // "Hello, Go!"

// Разделить
parts := strings.Split(s, ", ")        // ["Hello" "World!"]

// Объединить
result := strings.Join(parts, "-")     // "Hello-World!"

// Builder (для конкатенации)
var b strings.Builder
b.WriteString("Hello")
b.WriteString(" ")
b.WriteString("World")
fmt.Println(b.String())  // "Hello World"
```

### strconv пакет
---
```go
import "strconv"

// String в числа
num, _ := strconv.Atoi("42")           // 42
num64, _ := strconv.ParseInt("42", 10, 64)  // 42
f, _ := strconv.ParseFloat("3.14", 64)  // 3.14

// Числа в string
str := strconv.Itoa(42)                // "42"
str := strconv.FormatInt(42, 10)       // "42"
str := strconv.FormatFloat(3.14, 'f', 2, 64)  // "3.14"

// Boolean
b, _ := strconv.ParseBool("true")      // true
str := strconv.FormatBool(true)        // "true"
```

### fmt пакет
---
```go
import "fmt"

// Печать
fmt.Println("Hello", "World")          // Hello World
fmt.Print("Hello")                      // HelloHello (без newline)
fmt.Printf("%d + %d = %d\n", 2, 3, 5) // 2 + 3 = 5

// Форматирование в строку
s := fmt.Sprintf("Value: %d", 42)      // "Value: 42"

// Parsef (как scanf в C)
var x int
fmt.Sscanf("42", "%d", &x)
```

### sort пакет
---
```go
import "sort"

// Встроенные типы
numbers := []int{3, 1, 4, 1, 5}
sort.Ints(numbers)  // [1, 1, 3, 4, 5]

strings := []string{"b", "a", "c"}
sort.Strings(strings)  // [a, b, c]

// Кастомная сортировка
type Person struct {
    Name string
    Age  int
}

people := []Person{
    {"Ivan", 30},
    {"Maria", 25},
    {"Alex", 35},
}

sort.Slice(people, func(i, j int) bool {
    return people[i].Age < people[j].Age
})
// [Maria 25, Ivan 30, Alex 35]
```

### regexp пакет (регулярные выражения)
---
```go
import "regexp"

// Компилировать regex
re := regexp.MustCompile(`^[a-z]+@[a-z]+\.[a-z]+$`)

// Проверить совпадение
if re.MatchString("test@example.com") {
    fmt.Println("Valid email")
}

// Найти совпадение
match := re.FindString("My email is test@example.com")
fmt.Println(match)  // "test@example.com"

// Найти все совпадения
matches := re.FindAllString("a1b2c3", -1)
fmt.Println(matches)  // ["a" "b" "c"]

// Заменить
result := re.ReplaceAllString("a1b2c3", "X")
fmt.Println(result)  // "XXX"
```

### math пакет
---
```go
import "math"

fmt.Println(math.Pi)          // 3.1415926535897932
fmt.Println(math.Sin(math.Pi/2))  // 1
fmt.Println(math.Pow(2, 3))   // 8
fmt.Println(math.Sqrt(16))    // 4
fmt.Println(math.Abs(-42))    // 42
fmt.Println(math.Max(3, 5))   // 5
fmt.Println(math.Min(3, 5))   // 3
```

### math/rand пакет (случайные числа)
---
```go
import "math/rand"

// Случайное число от 0 до 99
n := rand.Intn(100)

// Случайный float от 0 до 1
f := rand.Float64()

// Shuffle slice
numbers := []int{1, 2, 3, 4, 5}
rand.Shuffle(len(numbers), func(i, j int) {
    numbers[i], numbers[j] = numbers[j], numbers[i]
})
```

# Правило для собеседования
---
**Когда спрашивают про стандартную библиотеку, отвечай:**

"Go имеет отличную стандартную библиотеку. Я часто использую:
- sync для синхронизации (WaitGroup, Mutex, Once)
- time для работы с временем
- io для работы с Reader/Writer интерфейсами
- strings для работы со строками
- strconv для конвертации типов
- sort для сортировки
- regexp для регулярных выражений

Я также стараюсь использовать стандартную библиотеку вместо внешних пакетов, когда это возможно, потому что это стабильнее и не добавляет зависимостей."

---

**[← Назад к Go углубленно](../)**
