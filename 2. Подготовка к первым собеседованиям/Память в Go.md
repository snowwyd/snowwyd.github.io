---
layout: default
title: Память и управление данными
permalink: /interview-prep/go-deep-dive/memory
---

# Цель
---
Понять, как Go управляет памятью, что такое указатели, как работает распределение памяти (stack vs heap), и как это влияет на производительность твоего кода. Это **базовое понимание**, без которого ты будешь писать код "вслепую".

# Зачем это нужно на собеседовании?
---
На собеседовании тебя точно спросят:
- Чем отличаются значимые и ссылочные типы?
- Когда нужно использовать указатели?
- Что такое stack и heap, и в чём разница?
- Почему передача большого struct'а указателем быстрее?

Если ты не можешь ответить на эти вопросы, интервьюер сразу поймёт, что ты пишешь код "по примерам", а не осознанно.

# Теория

### Память в компьютере
---
Память компьютера — это как огромный массив ячеек, каждая имеет свой адрес и может хранить данные.

```
Адрес памяти    |  Данные
    0x1000      |  int: 42
    0x1008      |  string: "Hello"
    0x1010      |  ...
```

Каждая переменная в Go занимает определённое место в памяти. Когда ты объявляешь переменную, Go должен **выделить место для неё** и **освободить его**, когда она больше не нужна.

### Stack vs Heap
---
Go использует **два типа памяти** для разных целей:

#### Stack (Стек)
**Что это:** Быстрая память, структурированная, работает как стопка тарелок (Last In, First Out).

**Как работает:**
- Переменные добавляются на stack, когда функция начинается
- Когда функция заканчивается, все её переменные автоматически удаляются
- **Это очень быстро** - просто сдвигаем указатель

**Что хранится в stack:**
- Примитивные типы: int, float64, bool, string
- Struct'ы (если они не очень большие)
- Массивы фиксированного размера

```go
func example() {
    x := 42                    // Stack
    name := "Ivan"             // Stack
    arr := [5]int{1, 2, 3, 4, 5}  // Stack
    // Когда функция заканчивается, все это автоматически удаляется
}
```

#### Heap (Кучка)
**Что это:** Более медленная память, но более гибкая. Всё, что не помещается на stack, идёт сюда.

**Как работает:**
- Когда нужна память, мы просим её "выделить" где-то на heap
- Мы получаем **адрес** (указатель), по которому находится наша память
- Освобождать нужно явно (в некоторых языках) или через garbage collector (в Go)
- **Это медленнее** - нужны поиски и перемещения

**Что хранится в heap:**
- Слайсы (сам слайс на stack, данные на heap)
- Map'ы
- Канали
- Указатели на struct'ы (если мы их создали через new или &)

```go
func example() {
    slice := []int{1, 2, 3}           // Слайс на stack, данные на heap
    m := map[string]int{"a": 1}       // Map на heap
    p := new(Person)                  // Указатель на heap
    // Garbage collector позже поймет, что это не нужно, и освободит память
}
```

**Визуально:**
```
STACK                          HEAP
┌─────────────┐               ┌──────────────┐
│ x: 42       │               │ slice data   │
│ name ptr────┼──────────────→│ [1, 2, 3]    │
│ arr: [...]  │               │              │
│ slice ptr───┼──────────────→│ slice data   │
│ map ptr─────┼──────────────→│ map data     │
└─────────────┘               └──────────────┘
```

### Указатели (Pointers)
---
**Указатель** — это переменная, которая хранит **адрес памяти** другой переменной.

**Зачем они нужны:**
1. Передавать данные функции без копирования (экономия памяти)
2. Изменять данные внутри функции и чтобы изменения "пробили" наружу
3. Создавать сложные структуры данных (связные списки, деревья)

**Как работают:**

```go
// Создание указателя
x := 42
p := &x              // & — оператор "адреса" (взять адрес переменной x)
fmt.Println(p)       // Вывод: 0xc0000140a0 (какой-то адрес в памяти)
fmt.Println(*p)      // * — оператор "разыменования" (получить значение по адресу)
                     // Вывод: 42

// Изменение через указатель
*p = 99
fmt.Println(x)       // Вывод: 99 (x изменился, потому что мы изменили по адресу)
```

**Тип указателя:** `*Type` означает "указатель на тип Type"

```go
var p *int           // Указатель на int (сейчас nil)
var q *string        // Указатель на string
var r *Person        // Указатель на struct Person

x := 42
p = &x               // Теперь p указывает на x
```

### Ссылочные и значимые типы
---
**Значимые типы** (Value Types):
- int, float64, bool, string, array, struct
- Хранятся на **stack**
- При передаче функции **копируется всё значение**

```go
func changeInt(x int) {
    x = 999
}

func main() {
    x := 42
    changeInt(x)
    fmt.Println(x)  // Вывод: 42 (не изменилось, так как копия изменилась)
}
```

**Ссылочные типы** (Reference Types):
- slice, map, channel, interface
- Хранятся на **heap**, а "дескриптор" на stack
- При передаче функции копируется только дескриптор (быстро)

```go
func changeSlice(s []int) {
    s[0] = 999
}

func main() {
    s := []int{1, 2, 3}
    changeSlice(s)
    fmt.Println(s)  // Вывод: [999 2 3] (изменилось, потому что обе переменные указывают на один массив)
}
```

### Когда использовать указатели
---

#### ✅ ИСПОЛЬЗУЙ указатели когда:

**1. Хочешь изменить данные функции:**
```go
func incrementAge(p *Person) {
    p.Age++
}

person := Person{Name: "Ivan", Age: 30}
incrementAge(&person)  // Передаём адрес
fmt.Println(person.Age)  // 31
```

**2. Struct очень большой (много памяти):**
```go
type User struct {
    ID       int64
    Name     string
    Email    string
    Phone    string
    Address  string
    // ... ещё 100 полей
}

// ❌ Плохо: копируем весь struct
func processUserBad(u User) { }

// ✅ Хорошо: копируем только указатель (8 байт)
func processUserGood(u *User) { }
```

**3. Нужна цепочка изменений:**
```go
func (p *Person) SetAge(age int) *Person {
    p.Age = age
    return p
}

person := &Person{Name: "Ivan"}
person.SetAge(30).SetAge(31)  // Fluent API - только с указателями
```

#### ❌ НЕ ИСПОЛЬЗУЙ указатели когда:

**1. Примитивные типы (int, string, bool):**
```go
// ❌ Плохо
func printInt(x *int) {
    fmt.Println(*x)
}

// ✅ Хорошо
func printInt(x int) {
    fmt.Println(x)
}
```

**2. Не нужно изменять данные:**
```go
// ❌ Плохо
func getAge(p *Person) int {
    return p.Age
}

// ✅ Хорошо
func getAge(p Person) int {
    return p.Age
}
```

**3. Передаёшь slice или map:**
```go
// ❌ Редко нужно, эти типы уже ссылочные
func processList(s *[]int) { }

// ✅ Обычно так
func processList(s []int) { }
```

## Практический пример: Stack vs Heap

```go
package main

import "fmt"

type Person struct {
    Name string
    Age  int
}

func main() {
    // Это на STACK
    p1 := Person{Name: "Ivan", Age: 30}
    
    // Это на HEAP (указатель на Person)
    p2 := &Person{Name: "Maria", Age: 25}
    
    // Когда мы передаём p1, копируется весь struct (медленнее)
    printPersonBad(p1)
    
    // Когда мы передаём p2, копируется только адрес (быстрее)
    printPersonGood(p2)
}

func printPersonBad(p Person) {
    fmt.Println(p.Name, p.Age)
}

func printPersonGood(p *Person) {
    fmt.Println(p.Name, p.Age)
}
```

# Правило для собеседования
---
**Когда спрашивают про указатели, отвечай:**

"Указатели в Go используются для трёх целей:
1. Экономии памяти при передаче больших struct'ов
2. Изменения данных внутри функции, чтобы это отразилось снаружи
3. Создания сложных структур данных

Значимые типы (int, struct) копируются, а ссылочные (slice, map) передаются по ссылке. Я использую указатели, только когда это действительно необходимо, чтобы не усложнять код без причины."

---

**[← Назад к Go углубленно](../)**
