---
layout: default
title: Конкурентность - продвинутые паттерны
permalink: /interview-prep/go-deep-dive/concurrency-patterns/
---

# Цель
---
Теперь, когда ты знаешь базовые примитивы, пришло время изучить **паттерны**, которые используются в production коде. Context, Worker Pool, Fan-out/Fan-in, Rate Limiter — это не теория, а реальный код, который ты встретишь в боевых проектах.

# Зачем это нужно на собеседовании?
---
Тебя спросят:
- Как правильно использовать context?
- Что такое worker pool и когда его использовать?
- Как реализовать rate limiting?
- Как делается fan-out/fan-in?
- Как корректно отменять операции?

Эти вопросы — признак, что ты кандидат для Middle+ уровня.

# Теория

### Context
---
**Context** — это объект, который передаёт "сигналы" между горутинами:
- Сигнал на отмену (Cancel)
- Сигнал на timeout
- Значения (values), которые нужны всем горутинам

**Главный паттерн в Go:** Каждая функция, которая может быть долгой, должна принимать `context.Context`.

```go
// ❌ Плохо: нет context
func fetchData(url string) ([]byte, error) {
    // Что если вызывающий захочет отменить эту операцию?
    // Ничего нельзя сделать!
}

// ✅ Хорошо: есть context
func fetchData(ctx context.Context, url string) ([]byte, error) {
    // Теперь вызывающий может отменить операцию
}
```

**Иерархия контекстов:**
```
Background (корень)
    ├─ Context с timeout (20 сек)
    │   ├─ Context с cancel
    │   └─ Context с values
    └─ Context с cancel
```

**Основные операции:**

```go
// 1. Background — пустой контекст (никогда не отменяется)
ctx := context.Background()

// 2. Context с timeout — отменяется через 5 секунд
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()  // Важно! Очищаем ресурсы

// 3. Context с cancel — отменяется когда мы вызовём cancel()
ctx, cancel := context.WithCancel(context.Background())
go func() {
    time.Sleep(1 * time.Second)
    cancel()  // Отменяем контекст
}()

// 4. Context со значениями
ctx := context.WithValue(context.Background(), "userID", 123)
userID := ctx.Value("userID")  // 123
```

**Проверка отмены:**
```go
func doSomething(ctx context.Context) error {
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()  // Context был отменён или истёк timeout
        default:
            // Делаем работу
        }
    }
}
```

### Worker Pool
---
**Worker Pool** — это паттерн, когда вы имеете фиксированное количество "рабочих" (горутин), которые обрабатывают задачи из очереди.

**Зачем это нужно?**
- Нельзя просто создать по горутине на каждую задачу (их может быть миллионы)
- 10 рабочих смогут обработать миллионы задач поочередно
- Это экономит память и процессор

**Реализация:**
```go
package main

import (
    "fmt"
    "sync"
)

func worker(id int, jobs <-chan int, results chan<- string) {
    for job := range jobs {
        fmt.Printf("Worker %d processing job %d\n", id, job)
        results <- fmt.Sprintf("Result of job %d", job)
    }
}

func main() {
    jobs := make(chan int, 100)
    results := make(chan string, 100)
    
    // Создаём 5 рабочих
    for w := 1; w <= 5; w++ {
        go worker(w, jobs, results)
    }
    
    // Даём им 10 задач
    for j := 1; j <= 10; j++ {
        jobs <- j
    }
    close(jobs)
    
    // Получаем все результаты
    for a := 1; a <= 10; a++ {
        fmt.Println(<-results)
    }
}
```

**Output:**
```
Worker 1 processing job 1
Worker 2 processing job 2
Worker 3 processing job 3
Worker 4 processing job 4
Worker 5 processing job 5
Worker 1 processing job 6
Worker 2 processing job 7
...
```

### Fan-out / Fan-in
---
**Fan-out:** Одна горутина отправляет данные в несколько горутин

**Fan-in:** Несколько горутин отправляют данные в одну

```go
package main

import "fmt"

// Fan-out: функция отправляет один элемент нескольким получателям
func fanOut(input <-chan int, outputs ...chan<- int) {
    for val := range input {
        for _, out := range outputs {
            out <- val
        }
    }
    for _, out := range outputs {
        close(out)
    }
}

// Fan-in: функция собирает от нескольких отправителей в один канал
func fanIn(inputs ...chan string) <-chan string {
    result := make(chan string)
    var wg sync.WaitGroup
    
    for _, input := range inputs {
        wg.Add(1)
        go func(ch <-chan string) {
            defer wg.Done()
            for val := range ch {
                result <- val
            }
        }(input)
    }
    
    go func() {
        wg.Wait()
        close(result)
    }()
    
    return result
}

func main() {
    // Fan-out
    input := make(chan int)
    out1 := make(chan int)
    out2 := make(chan int)
    
    go fanOut(input, out1, out2)
    
    go func() {
        input <- 1
        input <- 2
        close(input)
    }()
    
    // Fan-in
    inputs1 := make(chan string)
    inputs2 := make(chan string)
    results := fanIn(inputs1, inputs2)
    
    go func() {
        inputs1 <- "Message 1"
        inputs1 <- "Message 2"
        close(inputs1)
    }()
    
    go func() {
        inputs2 <- "Message 3"
        inputs2 <- "Message 4"
        close(inputs2)
    }()
    
    for msg := range results {
        fmt.Println(msg)
    }
}
```

### Rate Limiter (Ограничитель частоты)
---
**Rate Limiter** — механизм, который ограничивает количество операций в единицу времени.

**Зачем нужен?**
- API может обрабатывать только N запросов в секунду
- Нужно защитить систему от перегрузки
- Нужно контролировать использование ресурсов

**Реализация через channel:**
```go
import "time"

func main() {
    // Ограничиваем до 3 операций в секунду
    limiter := time.Tick(time.Second / 3)
    
    for i := 1; i <= 10; i++ {
        <-limiter  // Ждём разрешения
        fmt.Println("Request", i, "at", time.Now())
    }
}
```

**Output (3 запроса в секунду):**
```
Request 1 at 2024-01-01 12:00:00.000
Request 2 at 2024-01-01 12:00:00.333
Request 3 at 2024-01-01 12:00:00.667
Request 4 at 2024-01-01 12:00:01.000
...
```

**Более сложный пример (Token Bucket):**
```go
type RateLimiter struct {
    tokens chan struct{}
}

func NewRateLimiter(rps int) *RateLimiter {
    rl := &RateLimiter{
        tokens: make(chan struct{}, rps),
    }
    
    // Каждую секунду добавляем rps токенов
    go func() {
        ticker := time.NewTicker(time.Second / time.Duration(rps))
        defer ticker.Stop()
        
        for range ticker.C {
            select {
            case rl.tokens <- struct{}{}:
            default:
            }
        }
    }()
    
    return rl
}

func (rl *RateLimiter) Allow() bool {
    select {
    case <-rl.tokens:
        return true
    default:
        return false
    }
}

func main() {
    limiter := NewRateLimiter(3)  // 3 запроса в секунду
    
    for i := 1; i <= 10; i++ {
        if limiter.Allow() {
            fmt.Println("Request", i, "allowed")
        } else {
            fmt.Println("Request", i, "rejected")
        }
    }
}
```

### Pipeline (Конвейер)
---
**Pipeline** — это паттерн, когда данные проходят через несколько этапов обработки.

```go
// Этап 1: генерируем числа
func generate(max int) <-chan int {
    out := make(chan int)
    go func() {
        for i := 1; i <= max; i++ {
            out <- i
        }
        close(out)
    }()
    return out
}

// Этап 2: квадрируем
func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for num := range in {
            out <- num * num
        }
        close(out)
    }()
    return out
}

// Этап 3: удваиваем
func double(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for num := range in {
            out <- num * 2
        }
        close(out)
    }()
    return out
}

func main() {
    // 1 -> 4 -> 8
    // 2 -> 4 -> 8
    // 3 -> 9 -> 18
    // 4 -> 16 -> 32
    // 5 -> 25 -> 50
    
    for num := range double(square(generate(5))) {
        fmt.Println(num)
    }
}
```

## Практический пример: обработка URL с ограничением частоты

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

type Task struct {
    URL string
}

func processURL(ctx context.Context, url string) string {
    select {
    case <-ctx.Done():
        return fmt.Sprintf("Cancelled: %s", url)
    default:
        time.Sleep(1 * time.Second)
        return fmt.Sprintf("Processed: %s", url)
    }
}

func main() {
    urls := []string{
        "http://example1.com",
        "http://example2.com",
        "http://example3.com",
        "http://example4.com",
        "http://example5.com",
    }
    
    // Worker pool с rate limiting
    jobs := make(chan string, 10)
    results := make(chan string, 10)
    
    // 3 рабочих
    var wg sync.WaitGroup
    for w := 1; w <= 3; w++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            // Rate limit: 1 задача в секунду
            limiter := time.NewTicker(time.Second)
            defer limiter.Stop()
            
            for job := range jobs {
                <-limiter.C
                ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                result := processURL(ctx, job)
                cancel()
                results <- result
            }
        }(w)
    }
    
    // Отправляем задачи
    go func() {
        for _, url := range urls {
            jobs <- url
        }
        close(jobs)
    }()
    
    // Получаем результаты
    go func() {
        wg.Wait()
        close(results)
    }()
    
    for result := range results {
        fmt.Println(result)
    }
}
```

# Правило для собеседования
---
**Когда спрашивают про продвинутые паттерны, отвечай:**

"В Production коде я использую Context для контроля отмены и timeout'ов. Это правило в Go — почти все долгие операции должны принимать Context.

Для обработки большого количества задач я использую Worker Pool — фиксированное количество горутин, которые обрабатывают задачи из очереди. Это экономит память.

Fan-out/Fan-in используется для распределения данных между несколькими горутинами и их сбора.

Rate Limiter защищает систему от перегрузки — я ограничиваю количество операций в единицу времени.

Pipeline используется, когда данные проходят через несколько этапов обработки."

---

**[← Назад к Go углубленно](../)**
