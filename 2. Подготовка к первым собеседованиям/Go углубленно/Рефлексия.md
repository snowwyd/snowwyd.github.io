---
layout: default
title: Reflection и метапрограммирование
permalink: /interview-prep/go-deep-dive/reflection/
---

# Цель
---
Reflection позволяет программе исследовать и изменять структуры во время выполнения. Это мощный инструмент, но его легко неправильно использовать. Ты должен понять, когда reflection полезен, а когда его нужно избегать.

# Зачем это нужно на собеседовании?
---
Тебя спросят:
- Как работает пакет reflect?
- Когда использовать reflection?
- В чём опасность reflection?
- Как получить информацию о типе во время выполнения?
- Когда reflection даёт реальное преимущество?

Это вопрос для продвинутых интервьюеров.

# Теория

### Основы: Type и Value
---
**Reflection** — это возможность исследовать типы и значения во время выполнения программы.

```go
import "reflect"

x := 42
t := reflect.TypeOf(x)    // Тип переменной
v := reflect.ValueOf(x)   // Значение переменной

fmt.Println(t)            // "int"
fmt.Println(v)            // "42"
fmt.Println(v.Kind())     // "int"
```

**Разница между Type и Value:**
- `Type` — информация о типе (int, string, struct)
- `Value` — само значение + информация о типе

### Получение информации о типе
---

#### Структура
```go
type Person struct {
    Name string `json:"name"`
    Age  int    `json:"age"`
}

p := Person{Name: "Ivan", Age: 30}
t := reflect.TypeOf(p)

// Количество полей
fmt.Println(t.NumField())  // 2

// Информация о каждом поле
for i := 0; i < t.NumField(); i++ {
    field := t.Field(i)
    fmt.Println(field.Name)      // Name, Age
    fmt.Println(field.Type)      // string, int
    fmt.Println(field.Tag)       // json:"name", json:"age"
}
```

#### Методы
```go
func (p Person) String() string {
    return "Person: " + p.Name
}

t := reflect.TypeOf(Person{})

// Количество методов
fmt.Println(t.NumMethod())  // 1

// Информация о методе
method := t.Method(0)
fmt.Println(method.Name)    // "String"
fmt.Println(method.Type)    // func(main.Person) string
```

### Вызов методов через Reflection
---
```go
type Calculator struct {
    value int
}

func (c Calculator) Add(x int) int {
    return c.value + x
}

func (c Calculator) Multiply(x int) int {
    return c.value * x
}

// Вызвать метод "Add" с аргументом 5
calc := Calculator{value: 10}
v := reflect.ValueOf(calc)

// Получаем метод
method := v.MethodByName("Add")

// Вызываем метод
args := []reflect.Value{reflect.ValueOf(5)}
result := method.Call(args)

fmt.Println(result[0].Int())  // 15
```

### Изменение значений через Reflection
---
```go
type Config struct {
    Host string
    Port int
}

c := Config{Host: "localhost", Port: 8080}
v := reflect.ValueOf(&c)  // Нужен указатель!

// Получаем поле Host
field := v.Elem().FieldByName("Host")

// Проверяем, можно ли изменить
if field.CanSet() {
    field.SetString("example.com")
}

fmt.Println(c.Host)  // "example.com"
```

### Создание новых объектов
---
```go
// Создать новый slice типа []int
sliceType := reflect.SliceOf(reflect.TypeOf(0))
newSlice := reflect.MakeSlice(sliceType, 0, 10)
fmt.Println(newSlice)  // []

// Добавить элемент
newSlice = reflect.Append(newSlice, reflect.ValueOf(42))
fmt.Println(newSlice.Index(0).Int())  // 42
```

### Reflection для сериализации (как JSON)
---
```go
// Кастомный JSON encoder используя reflection
func customMarshal(v interface{}) (string, error) {
    val := reflect.ValueOf(v)
    
    if val.Kind() != reflect.Struct {
        return "", fmt.Errorf("expected struct")
    }
    
    var result string
    result += "{"
    
    for i := 0; i < val.NumField(); i++ {
        field := val.Type().Field(i)
        value := val.Field(i)
        
        result += fmt.Sprintf("\"%s\":%v,", field.Name, value)
    }
    
    result += "}"
    return result, nil
}

p := Person{Name: "Ivan", Age: 30}
json, _ := customMarshal(p)
fmt.Println(json)  // {"Name":"Ivan","Age":30,}
```

### Опасность Reflection
---

#### Проблема 1: Производительность
```go
// ❌ Медленно
for i := 0; i < 1000000; i++ {
    v := reflect.ValueOf(x)
    v.FieldByName("Name").SetString("test")
}

// ✅ Быстро
for i := 0; i < 1000000; i++ {
    x.Name = "test"
}
```

Reflection может быть в **100 раз медленнее**!

#### Проблема 2: Runtime ошибки
```go
// ❌ Плохо: ошибка только во время выполнения
field := v.FieldByName("NonExistent")  // Паника!

// ✅ Хорошо: проверяем перед тем, как использовать
field := v.FieldByName("NonExistent")
if !field.IsValid() {
    fmt.Println("Field not found")
}
```

#### Проблема 3: Сложный код
```go
// ❌ Очень сложно понять
v := reflect.ValueOf(&s).Elem()
f := v.FieldByName("X")
if f.IsValid() && f.CanSet() {
    f.Set(reflect.ValueOf(42))
}

// ✅ Просто и понятно
s.X = 42
```

### Когда использовать Reflection
---

#### ✅ ИСПОЛЬЗУЙ Reflection когда:

**1. Нужна универсальная функция, которая работает с разными типами**
```go
// Лучше использовать interface{}
func printFields(v interface{}) {
    val := reflect.ValueOf(v)
    if val.Kind() != reflect.Struct {
        return
    }
    
    for i := 0; i < val.NumField(); i++ {
        fmt.Println(val.Type().Field(i).Name)
    }
}

type Person struct {
    Name string
    Age  int
}

type Car struct {
    Model string
    Year  int
}

printFields(Person{})  // Name, Age
printFields(Car{})     // Model, Year
```

**2. Работа с tags (как JSON, YAML, etc.)**
```go
type User struct {
    Name string `json:"name" db:"user_name"`
    Age  int    `json:"age" db:"user_age"`
}

// Читаем tags
t := reflect.TypeOf(User{})
for i := 0; i < t.NumField(); i++ {
    field := t.Field(i)
    jsonTag := field.Tag.Get("json")
    dbTag := field.Tag.Get("db")
    fmt.Printf("%s: json=%s, db=%s\n", field.Name, jsonTag, dbTag)
}
```

**3. ORM и фреймворки (внутренняя реализация)**
```
gorm, sqlc, protobuf — всё это использует reflection внутри
```

#### ❌ НЕ ИСПОЛЬЗУЙ Reflection когда:

**1. Можешь использовать интерфейсы**
```go
// ❌ С reflection
func Process(v interface{}) {
    val := reflect.ValueOf(v)
    method := val.MethodByName("Process")
    method.Call([]reflect.Value{})
}

// ✅ С интерфейсом
type Processor interface {
    Process()
}

func Process(p Processor) {
    p.Process()
}
```

**2. Нужна производительность**
```go
// ❌ Медленно
for i := 0; i < 10000000; i++ {
    reflect.ValueOf(&obj).Elem().FieldByName("X").SetInt(42)
}

// ✅ Быстро
for i := 0; i < 10000000; i++ {
    obj.X = 42
}
```

### Пример: Custom ORM
---
```go
type Model struct {
    ID    int
    Name  string
    Email string
}

// Получить значения всех полей
func getFieldValues(v interface{}) map[string]interface{} {
    result := make(map[string]interface{})
    val := reflect.ValueOf(v)
    typ := reflect.TypeOf(v)
    
    for i := 0; i < val.NumField(); i++ {
        field := typ.Field(i)
        value := val.Field(i)
        result[field.Name] = value.Interface()
    }
    
    return result
}

// Использование
m := Model{ID: 1, Name: "Ivan", Email: "ivan@example.com"}
values := getFieldValues(m)
// map[string]interface{}{
//     "ID": 1,
//     "Name": "Ivan",
//     "Email": "ivan@example.com",
// }
```

# Правило для собеседования
---
**Когда спрашивают про reflection, отвечай:**

"Reflection в Go позволяет исследовать типы и значения во время выполнения. Это мощный инструмент, но его нужно использовать осторожно.

Я использую reflection редко — в основном для:
1. Работы с тегами структур (как в JSON маршализаторе)
2. Создания универсальных функций через interface{}
3. Во фреймворках и ORM библиотеках

Reflection имеет высокую стоимость производительности, поэтому я избегаю его в горячих путях. Обычно интерфейсы решают проблему лучше.

Я также проверяю значения перед использованием reflection, чтобы избежать runtime паник."

---

**[← Назад к Go углубленно](../)**
