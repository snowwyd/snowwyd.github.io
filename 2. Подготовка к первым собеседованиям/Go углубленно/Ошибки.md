---
layout: default
title: Ошибки и обработка исключений
permalink: /interview-prep/go-deep-dive/errors/
---

# Цель
---
В Go нет try-catch, как в других языках. Вместо этого есть **своя философия** работы с ошибками. Ты должен понять, как правильно обрабатывать ошибки, создавать собственные типы ошибок, и когда использовать panic.

# Зачем это нужно на собеседовании?
---
Тебя спросят:
- Как работают ошибки в Go?
- Почему в Go нет исключений?
- Как правильно обрабатывать ошибки?
- Когда использовать panic/recover?
- Как создавать собственные типы ошибок?

Ответ покажет, разбираешься ли ты в идеологии Go.

# Теория

### Основы: error интерфейс
---
**Error** — это просто интерфейс с одним методом:

```go
type error interface {
    Error() string
}
```

**Любой тип, который реализует этот метод — это error!**

```go
// Самый простой error
errors.New("something went wrong")

// Более информативный
fmt.Errorf("failed to read file: %v", err)
```

### Обработка ошибок: базовый паттерн
---
**В Go принято проверять ошибку сразу после операции:**

```go
// ✅ Правильно в Go
data, err := ioutil.ReadFile("file.txt")
if err != nil {
    return err  // Или обработать ошибку
}
// Используем data

// ❌ Не по Go
try {
    data = readFile("file.txt")
} catch (err) {
    // обработка
}
```

**Главный принцип:** Явная обработка ошибок, а не их скрывание.

### Проверка типов ошибок
---
Иногда тебе нужно узнать **конкретный тип** ошибки.

```go
// Type assertion
if err != nil {
    if ioErr, ok := err.(net.Error); ok && ioErr.Timeout() {
        fmt.Println("Network timeout")
    }
}

// Или через errors.Is (Go 1.13+)
if errors.Is(err, os.ErrNotExist) {
    fmt.Println("File not found")
}
```

**Стандартные ошибки:**
```go
os.ErrNotExist       // Файл не существует
os.ErrPermission     // Нет прав
io.EOF               // Конец файла
net.ErrClosed        // Соединение закрыто
```

### Создание собственных ошибок
---

#### Способ 1: Простая функция
```go
func validate(age int) error {
    if age < 0 {
        return fmt.Errorf("invalid age: %d", age)
    }
    return nil
}

err := validate(-5)
if err != nil {
    fmt.Println(err)  // "invalid age: -5"
}
```

#### Способ 2: Custom тип ошибки
```go
type ValidationError struct {
    Field   string
    Message string
}

func (e ValidationError) Error() string {
    return fmt.Sprintf("validation error on %s: %s", e.Field, e.Message)
}

func validate(age int) error {
    if age < 0 {
        return ValidationError{
            Field:   "age",
            Message: "must be positive",
        }
    }
    return nil
}

// Проверка типа
if err != nil {
    if ve, ok := err.(ValidationError); ok {
        fmt.Println("Invalid field:", ve.Field)
    }
}
```

#### Способ 3: Wrapping ошибок (Go 1.13+)
```go
import "errors"

func readConfig(path string) error {
    data, err := ioutil.ReadFile(path)
    if err != nil {
        return fmt.Errorf("failed to read config from %s: %w", path, err)
        //                                                      ^ оборачиваем
    }
    // ...
}

// Проверка оригинальной ошибки
if errors.Is(err, os.ErrNotExist) {
    fmt.Println("Config file not found")
}
```

**Почему это важно?** Ты не теряешь информацию об оригинальной ошибке!

```go
// ❌ Плохо: оригинальная ошибка теряется
return fmt.Errorf("some error: %v", err)

// ✅ Хорошо: оригинальная ошибка сохраняется
return fmt.Errorf("some error: %w", err)
```

### Панические ситуации
---
**Panic** — это когда программа аварийно заканчивается.

```go
panic("something terrible happened!")
```

**Когда использовать panic?**
- ❌ Когда ошибка может быть обработана (используй error)
- ❌ Когда ошибка входит в данные (используй error)
- ✅ Когда что-то совсем невозможное (индекс за границами массива)
- ✅ Когда инициализация не удалась (конфиг файл не найден)

```go
// ✅ Правильно паниковать
data := json.Unmarshal(invalidJSON)  // Невалидный JSON — паника

// ❌ Неправильно паниковать
if userAge < 0 {
    panic("negative age")  // Это обрабатываемая ошибка!
}
```

### Recover
---
**Recover** — это способ "поймать" панику и продолжить работу.

```go
defer func() {
    if r := recover(); r != nil {
        fmt.Println("Recovered from panic:", r)
    }
}()

panic("oops!")
fmt.Println("This will not be printed")
```

**Output:**
```
Recovered from panic: oops!
```

**Когда использовать recover?**
- ✅ Веб-серверы (чтобы один запрос не убил весь сервер)
- ✅ Горутины (чтобы одна горутина не убила программу)
- ❌ Вместо error handling

```go
// ✅ Хорошее использование recover
func handleRequest() {
    defer func() {
        if r := recover(); r != nil {
            logger.Error("Request panicked:", r)
            writeErrorResponse()
        }
    }()
    
    processRequest()
}

// ❌ Плохое использование recover
func getUserAge() {
    defer func() {
        recover()  // Скрываем ошибку!
    }()
    
    age := data["age"].(int)  // Может запаниковать
    return age
}
```

### Структурированная обработка ошибок
---
**Go 1.13** добавил два метода в пакет errors:

#### errors.Is()
```go
if errors.Is(err, os.ErrNotExist) {
    fmt.Println("File not found")
}
```

#### errors.As()
```go
var syntaxErr *json.SyntaxError
if errors.As(err, &syntaxErr) {
    fmt.Println("JSON error at", syntaxErr.Offset)
}
```

### Best practices
---

#### 1. Проверяй ошибку сразу
```go
// ✅ Хорошо
data, err := fetch()
if err != nil {
    return err
}

// ❌ Плохо
data, err := fetch()
// ... 20 строк кода
if err != nil {
    return err
}
```

#### 2. Не игнорируй ошибки
```go
// ❌ Плохо
json.Unmarshal(data, &obj)  // Может вернуть ошибку

// ✅ Хорошо
if err := json.Unmarshal(data, &obj); err != nil {
    return err
}
```

#### 3. Оборачивай с контекстом
```go
// ❌ Плохо
return err

// ✅ Хорошо
return fmt.Errorf("failed to process user %d: %w", userID, err)
```

#### 4. Создавай sentinels ошибок
```go
// Определи специфичные ошибки
var (
    ErrNotFound    = errors.New("not found")
    ErrUnauthorized = errors.New("unauthorized")
    ErrInvalidInput = errors.New("invalid input")
)

// Используй их
func getUser(id string) (*User, error) {
    if id == "" {
        return nil, ErrInvalidInput
    }
    if !userExists(id) {
        return nil, ErrNotFound
    }
    // ...
}

// Проверяй
if errors.Is(err, ErrNotFound) {
    return 404
}
```

## Практический пример: полная обработка ошибок

```go
package main

import (
    "errors"
    "fmt"
    "os"
)

//定义 sentinels
var (
    ErrEmptyName    = errors.New("name cannot be empty")
    ErrNegativeAge  = errors.New("age cannot be negative")
)

// Custom тип ошибки
type UserValidationError struct {
    Field   string
    Message string
    err     error
}

func (e UserValidationError) Error() string {
    return fmt.Sprintf("validation error: %s - %s", e.Field, e.Message)
}

// Функция с обработкой ошибок
func createUser(name string, age int) error {
    if name == "" {
        return fmt.Errorf("failed to create user: %w", ErrEmptyName)
    }
    
    if age < 0 {
        return UserValidationError{
            Field:   "age",
            Message: "age must be positive",
        }
    }
    
    // Успех
    return nil
}

func main() {
    // Тест 1: пустое имя
    if err := createUser("", 30); err != nil {
        if errors.Is(err, ErrEmptyName) {
            fmt.Println("User must have a name")
        }
    }
    
    // Тест 2: отрицательный возраст
    if err := createUser("Ivan", -5); err != nil {
        var ve UserValidationError
        if errors.As(err, &ve) {
            fmt.Println("Invalid field:", ve.Field)
        }
    }
    
    // Тест 3: успех
    if err := createUser("Ivan", 30); err != nil {
        fmt.Println("Error:", err)
    } else {
        fmt.Println("User created successfully")
    }
}
```

# Правило для собеседования

**Когда спрашивают про ошибки, отвечай:**

"В Go нет исключений, вместо этого используются ошибки как обычные значения. Я всегда проверяю ошибку сразу после операции.

Я оборачиваю ошибки с контекстом, используя fmt.Errorf с %w, чтобы сохранить оригинальную ошибку. Это позволяет вышестоящему коду проверить конкретную ошибку через errors.Is() или errors.As().

Panic я использую редко — только для по-настоящему невозможных ситуаций. Recover нужен для защиты горутин, но не как замена error handling.

Я также создаю sentinel ошибки и custom типы ошибок для специфичных случаев, чтобы вызывающий код мог правильно обработать проблему."

---

**[← Назад к Go углубленно](../)**
