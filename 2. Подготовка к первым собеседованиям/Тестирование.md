---
layout: default
title: Тестирование
permalink: /interview-prep/go-deep-dive/testing/
---

# Цель
---
Писать тесты — это не лишнее, а **необходимое**. Ты должен знать, как писать unit тесты, использовать table-driven tests, создавать mock'и, и профилировать производительность через бенчмарки.

# Зачем это нужно на собеседовании?
---
Тебя спросят:
- Как писать unit тесты в Go?
- Что такое table-driven tests?
- Как создавать mock'и для функций?
- Как профилировать код через бенчмарки?
- Как достичь хорошего покрытия тестами?

Хороший кандидат **всегда** пишет тесты.

# Теория

### Основы: Unit тесты
---
**Unit тест** — это функция, которая проверяет, работает ли определённый кусок кода правильно.

```go
// math.go
func Add(a, b int) int {
    return a + b
}

// math_test.go
package main

import "testing"

func TestAdd(t *testing.T) {
    result := Add(2, 3)
    if result != 5 {
        t.Errorf("Expected 5, got %d", result)
    }
}
```

**Правила:**
- Файл должен заканчиваться на `_test.go`
- Функция должна начинаться с `Test` и принимать `*testing.T`
- Используй `t.Errorf()` для ошибок
- Используй `t.Fatalf()` для критических ошибок

**Запуск тестов:**
```bash
go test           # Запустить тесты в текущей папке
go test ./...     # Запустить тесты везде
go test -v        # Verbose режим
go test -run TestAdd  # Запустить только TestAdd
```

### Table-Driven Tests
---
**Table-Driven Test** — это паттерн, когда ты проверяешь одну функцию с разными входными данными.

```go
func TestAdd(t *testing.T) {
    tests := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"positive", 2, 3, 5},
        {"negative", -1, -1, -2},
        {"zero", 0, 0, 0},
        {"mixed", 5, -3, 2},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b)
            if result != tt.expected {
                t.Errorf("got %d, want %d", result, tt.expected)
            }
        })
    }
}
```

**Output:**
```
--- PASS: TestAdd (0.00s)
    --- PASS: TestAdd/positive (0.00s)
    --- PASS: TestAdd/negative (0.00s)
    --- PASS: TestAdd/zero (0.00s)
    --- PASS: TestAdd/mixed (0.00s)
```

**Преимущества:**
- Легко добавлять новые тест-кейсы
- Понятное имя для каждого теста
- Одна функция проверяет много случаев

### Готовка данных (Setup и Teardown)
---
```go
func TestDatabase(t *testing.T) {
    // Setup: подготовка
    db := setupTestDB()
    defer db.Close()  // Teardown: очистка
    
    // Тест
    user, err := db.GetUser(1)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
    
    if user.Name != "Ivan" {
        t.Errorf("expected Ivan, got %s", user.Name)
    }
}

func setupTestDB() *TestDB {
    // Создаём временную БД
    return &TestDB{}
}
```

### Sub-tests
---
```go
func TestUserCreation(t *testing.T) {
    t.Run("valid user", func(t *testing.T) {
        user := createUser("Ivan", 30)
        if user.Name != "Ivan" {
            t.Error("name mismatch")
        }
    })
    
    t.Run("invalid name", func(t *testing.T) {
        user := createUser("", 30)
        if user.Name != "" {
            t.Error("should reject empty name")
        }
    })
}
```

### Mock'и и Stub'и
---
**Mock** — это объект, который имитирует настоящий сервис для тестирования.

```go
// Настоящий интерфейс
type UserRepository interface {
    GetUser(id int) (*User, error)
}

// Mock для тестирования
type MockUserRepository struct {
    GetUserFunc func(id int) (*User, error)
}

func (m *MockUserRepository) GetUser(id int) (*User, error) {
    return m.GetUserFunc(id)
}

// Тест
func TestGetUserService(t *testing.T) {
    mock := &MockUserRepository{
        GetUserFunc: func(id int) (*User, error) {
            return &User{ID: 1, Name: "Ivan"}, nil
        },
    }
    
    service := NewUserService(mock)
    user, _ := service.GetUser(1)
    
    if user.Name != "Ivan" {
        t.Error("unexpected name")
    }
}
```

**Почему Mock'и классны?**
- Не нужна настоящая БД для тестирования
- Можешь имитировать ошибки
- Тесты выполняются быстро

### Бенчмарки (Benchmarks)
---
**Бенчмарк** — это тест производительности.

```go
// math_test.go
import "testing"

func BenchmarkAdd(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Add(2, 3)
    }
}
```

**Запуск:**
```bash
go test -bench=. -benchmem
```

**Output:**
```
BenchmarkAdd-8      1000000000       1.23 ns/op      0 B/op       0 allocs/op
```

**Что это значит?**
- `1000000000` — функция была вызвана 1 миллиард раз
- `1.23 ns/op` — одна операция занимает 1.23 наносекунды
- `0 B/op` — функция не выделила память на heap
- `0 allocs/op` — нет аллокаций

### Сложный бенчмарк
---
```go
func BenchmarkConcurrentMap(b *testing.B) {
    m := make(map[string]int)
    
    // Setup
    for i := 0; i < 1000; i++ {
        m[fmt.Sprintf("key%d", i)] = i
    }
    
    b.ResetTimer()  // Сбрасываем счётчик
    
    for i := 0; i < b.N; i++ {
        _ = m["key500"]
    }
}

// Тестирование с разным количеством элементов
func BenchmarkMapLookup(b *testing.B) {
    for _, size := range []int{10, 100, 1000} {
        b.Run(fmt.Sprintf("size-%d", size), func(b *testing.B) {
            m := make(map[string]int, size)
            for i := 0; i < size; i++ {
                m[fmt.Sprintf("key%d", i)] = i
            }
            
            b.ResetTimer()
            for i := 0; i < b.N; i++ {
                _ = m[fmt.Sprintf("key%d", size/2)]
            }
        })
    }
}
```

### Coverage (Покрытие тестами)
---
```bash
go test -cover
```

**Output:**
```
ok  mypackage  0.005s  coverage: 85.2% of statements
```

**Детальный coverage:**
```bash
go test -cover -coverprofile=coverage.out
go tool cover -html=coverage.out
```

### Практические примеры
---

#### 1. Тест с ошибками
```go
func TestValidateEmail(t *testing.T) {
    tests := []struct {
        email    string
        valid    bool
    }{
        {"ivan@example.com", true},
        {"invalid.email", false},
        {"@example.com", false},
        {"user@", false},
    }
    
    for _, tt := range tests {
        t.Run(tt.email, func(t *testing.T) {
            err := ValidateEmail(tt.email)
            isValid := err == nil
            if isValid != tt.valid {
                t.Errorf("got %v, want %v", isValid, tt.valid)
            }
        })
    }
}
```

#### 2. Тест с context и timeout
```go
func TestWithTimeout(t *testing.T) {
    ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
    defer cancel()
    
    // Должна закончиться за 100мс
    result, err := fetchWithContext(ctx)
    
    if err == context.DeadlineExceeded {
        t.Error("operation took too long")
    }
}
```

#### 3. Параллельные тесты
```go
func TestConcurrentRead(t *testing.T) {
    t.Parallel()  // Этот тест может выполняться параллельно с другими
    
    cache := NewCache()
    
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            cache.Set("key", "value")
        }(i)
    }
    
    wg.Wait()
}
```

# Правило для собеседования
---
**Когда спрашивают про тестирование, отвечай:**

"Я всегда пишу тесты. Использую table-driven pattern, чтобы проверить функцию с разными входными данными.

Для зависимостей (БД, API) я создаю mock'и через интерфейсы, что позволяет тестировать код в изоляции.

Бенчмарки помогают найти узкие места в коде и отслеживать регрессии производительности.

Я стараюсь достичь 70-80% покрытия — не нужно 100%, потому что это неэффективно. Фокусирую на критичных путях и ошибочных случаях."

---

**[← Назад к Go углубленно](../)**
