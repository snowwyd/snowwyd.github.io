---
layout: default
title: Типичные вопросы на собеседованиях
permalink: /interview-prep/databases-cache/postgresql/interviews/
---

# Цель
---
Этот файл содержит вопросы, которые часто спрашивают на собеседованиях для Middle разработчика. Читай внимательно, практикуй ответы вслух.

# Материалы
---
Используй этот файл как шпаргалку перед собеседованиями и для самопроверки.


## Архитектура и MVCC
---

**В1: Объясни, как работает MVCC в PostgreSQL. В чём отличие от традиционной блокировки?**

MVCC позволяет множеству транзакций параллельно читать и писать без блокировок. Вместо блокировки строки при UPDATE, PostgreSQL создаёт новую версию. Каждая транзакция видит снимок данных на момент её начала. Это позволяет читателям не блокировать писателей и наоборот.

Минус: накопление мёртвых версий (bloat), решается через VACUUM.


**В2: Расскажи про xmin и xmax. Как они используются?**

xmin и xmax — скрытые системные колонки:
- xmin: идентификатор транзакции, создавшей эту версию строки
- xmax: идентификатор транзакции, удалившей/обновившей строку (NULL если актуальна)

PostgreSQL использует их для определения видимости строки для каждой транзакции.


**В3: Что такое снимок транзакции? Когда он берётся?**

Снимок — информация о том, какие транзакции были активны на момент начала текущей транзакции. Берётся при BEGIN (для Repeatable Read) или при первом SELECT (для Read Committed).


## Уровни изоляции
---

**В4: Какие уровни изоляции существуют в PostgreSQL? Какой по умолчанию?**

SQL стандарт определяет 4, PostgreSQL реализует 3:
1. Read Uncommitted → ведёт себя как Read Committed
2. Read Committed (по умолчанию) — новый снимок для каждого SELECT
3. Repeatable Read — один снимок на всю транзакцию
4. Serializable — полная изоляция, может быть ошибка сериализации


**В5: Какой уровень использовать для финансовых операций?**

Обычно Repeatable Read или Serializable.

Repeatable Read: один снимок, консистентная работа с данными, редко требует перезапуска.

Serializable: полная изоляция, может быть ошибка сериализации (код 40001), требует логики повтора в приложении.


## Индексы
---

**В6: Какие типы индексов в PostgreSQL? Когда какой использовать?**

| Тип | Когда использовать |
|---|---|
| B-tree | Равенство (=), диапазоны (<, >), ORDER BY |
| Hash | Только равенство (=), редко используется |
| GIN | JSON, массивы, полнотекстовый поиск |
| BRIN | Большие отсортированные данные (логи, временные ряды) |


**В7: Что такое составной индекс? Как его использовать?**

Индекс по нескольким столбцам. Левая часть критична — если фильтруешь по правой колонке без левой, индекс не используется.

```sql
CREATE INDEX idx ON users(email, created_at);
-- Используется: WHERE email = '...'
-- Используется: WHERE email = '...' AND created_at > '...'
-- НЕ используется: WHERE created_at > '...'
```


**В8: Как найти неиспользуемые индексы?**

```sql
SELECT indexname FROM pg_stat_user_indexes WHERE idx_scan = 0;
```


## Оптимизация запросов
---

**В9: Как работает EXPLAIN ANALYZE? Что искать в выводе?**

EXPLAIN ANALYZE выполняет запрос и показывает реальное время и количество строк вместо оценки.

Ищи:
- Seq Scan вместо Index Scan → добавить индекс
- Реальное количество строк сильно отличается от оценки → обновить ANALYZE
- Большое количество обращений к диску → увеличить shared_buffers


**В10: Как оптимизировать медленный запрос?**

1. EXPLAIN ANALYZE — понимаем, что медленно
2. Добавляем индексы на колонки в WHERE и JOIN
3. Пересчитываем статистику: ANALYZE table
4. Переписываем запрос если нужно
5. Денормализуем если нужно


**В11: В чём разница между WHERE и ON в JOIN?**

ON — определяет условие соединения таблиц.
WHERE — фильтрует результат после соединения.

Для LEFT JOIN это критично: условие в WHERE может исключить строки без совпадений, а в ON — нет.


## SQL продвинуто
---

**В12: Объясни разницу между подзапросом и CTE. Когда какой использовать?**

Подзапрос — вложенный, может быть повторно выполнен.
CTE (WITH) — читаемый, можно повторно использовать в запросе.

Используй CTE для сложных запросов, подзапросы для простых фильтров.


**В13: Как работает GROUP BY с HAVING? В чём разница от WHERE?**

WHERE фильтрует строки ДО группировки.
HAVING фильтрует группы ПОСЛЕ группировки.

```sql
SELECT department, COUNT(*) as cnt
FROM employees
WHERE salary > 50000  -- Фильтруем сотрудников
GROUP BY department
HAVING COUNT(*) > 5;  -- Фильтруем группы
```


## Нормализация и проектирование
---

**В14: Объясни 3NF. Когда нужна денормализация?**

3NF — третья нормальная форма:
- 1NF: Атомарные значения
- 2NF: Нет зависимостей от части ключа
- 3NF: Нет транзитивных зависимостей

Денормализуй когда нагрузка на чтение намного больше, чем на запись, или много сложных JOIN замедляют аналитику.


**В15: Как обеспечить целостность данных через Foreign Key?**

```sql
CREATE TABLE orders (
  id INT PRIMARY KEY,
  user_id INT REFERENCES users(id) ON DELETE CASCADE
);
```

Опции: CASCADE (удалить связанные), SET NULL, RESTRICT (запретить удаление).


## Производительность
---

**В16: Как работает VACUUM и ANALYZE? Почему они важны?**

VACUUM: удаляет мёртвые версии строк от MVCC. Без него таблица раздувается.

ANALYZE: обновляет статистику для оптимизатора. Неправильная статистика → неправильные планы.


**В17: Что такое bloat в БД? Как его обнаружить?**

Bloat — накопление мёртвых страниц на диске.

```sql
SELECT tablename, n_dead_tup
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000;
```

Решение: VACUUM FULL или настроить autovacuum.


## Практические сценарии
---

**В18: Как обработать потенциальное состояние гонки в UPDATE?**

```sql
-- Вариант 1: FOR UPDATE
BEGIN;
SELECT balance FROM account WHERE id = 1 FOR UPDATE;  -- Блокируем строку
UPDATE account SET balance = balance - 100 WHERE id = 1;
COMMIT;

-- Вариант 2: Serializable уровень
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN;
  SELECT balance FROM account WHERE id = 1;
  UPDATE account SET balance = balance - 100 WHERE id = 1;
COMMIT;  -- Может быть ошибка, нужен повтор
```


**В19: Таблица растёт на миллиард строк в месяц. Как масштабировать?**

- Партиционирование: разделить на подтаблицы по дате
- BRIN индексы вместо B-tree
- Архивирование старых данных
- Репликация для балансирования нагрузки
- Кеширование на уровне приложения (Redis)


**В20: Как найти проблему в медленном запросе за 5 минут?**

1. EXPLAIN ANALYZE — посмотреть план
2. Найти Seq Scan на больших таблицах
3. Проверить разницу между оценкой и реальностью
4. Добавить индекс или обновить ANALYZE
5. Проверить снова


## Вопросы для самопроверки
---

1. Ты можешь объяснить MVCC коллеге?
2. Можешь назвать 3 типа индексов и когда их использовать?
3. Как найти проблему в медленном запросе за 5 минут?
4. В чём разница между Read Committed и Serializable?
5. Как обеспечить целостность данных между таблицами?

---

**[← Назад к PostgreSQL](../)**