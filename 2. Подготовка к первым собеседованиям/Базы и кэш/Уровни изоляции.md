---
layout: default
title: Уровни изоляции транзакций
permalink: /interview-prep/databases-cache/postgresql/isolation-levels/
---

# Цель
---
Здесь ты разберёшься с уровнями изоляции транзакций — как параллельно работающие транзакции видят друг друга. Это одна из самых частых тем на собеседованиях.

# Материалы
---
Рекомендую прочитать документацию по уровням изоляции.

[Документация по изоляции](https://postgrespro.ru/docs/postgresql/current/transaction-iso)


## Четыре уровня изоляции
---

SQL стандарт определяет четыре уровня изоляции. PostgreSQL реализует три из них благодаря MVCC.


## 1. Read Uncommitted
---

**По стандарту:** разрешает читать незафиксированные изменения от других транзакций.

**В PostgreSQL:** ведёт себя как Read Committed. Грязное чтение невозможно благодаря MVCC.

На практике в PostgreSQL это бесполезный уровень.


## 2. Read Committed (по умолчанию)
---

**Определение:** транзакция видит только данные, зафиксированные другими транзакциями.

**Особенности:**
- Каждый SELECT создаёт новый снимок
- Видны все изменения, зафиксированные между SELECT-ами
- Может привести к неповторяемому чтению

**Пример проблемы:**

```
Транзакция 1:
  SELECT balance FROM account WHERE id = 1;
  -- Результат: 1000

[Между первым и вторым SELECT]
  Транзакция 2:
    UPDATE account SET balance = 500 WHERE id = 1;
    COMMIT;

  Транзакция 1 продолжает:
  SELECT balance FROM account WHERE id = 1;
  -- Результат: 500 (изменилось!)
```

**Когда использовать:**
- Для большинства приложений
- Когда нужна хорошая конкурентность

```sql
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
BEGIN;
  SELECT balance FROM account WHERE id = 1;
  -- ... какой-то код ...
  SELECT balance FROM account WHERE id = 1;  -- Может быть другое значение
COMMIT;
```


## 3. Repeatable Read
---

**Определение:** транзакция видит согласованный снимок БД. Одна строка, прочитанная дважды, вернёт одно и то же значение.

**Особенности:**
- Один снимок на всю транзакцию (берётся при первом SELECT)
- Неповторяемое чтение невозможно
- Фантомное чтение **возможно** в PostgreSQL
- Может привести к ошибкам сериализации

**Пример:**

```
Транзакция 1:
  BEGIN;
  SELECT balance FROM account WHERE id = 1;  -- Берётся снимок, результат: 1000

[Параллельно]
  Транзакция 2:
    UPDATE account SET balance = 500 WHERE id = 1;
    COMMIT;

  Транзакция 1 продолжает:
  SELECT balance FROM account WHERE id = 1;  -- Всё ещё 1000!
COMMIT;
```

**Когда использовать:**
- Когда нужна стабильность данных внутри транзакции
- Для операций, требующих согласованности

```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;
  SELECT balance FROM account WHERE id = 1;  -- Берётся снимок
  -- Выполняем расчёты
  SELECT balance FROM account WHERE id = 1;  -- Вернёт то же значение
COMMIT;
```


## 4. Serializable
---

**Определение:** полная изоляция, как если бы транзакции выполнялись последовательно.

**Особенности:**
- Самый строгий уровень
- Может привести к ошибкам сериализации (код ошибки 40001)
- Требует логики повтора в приложении
- Медленнее других уровней

**Пример:**

```
Транзакция 1:
  BEGIN;
  SELECT COUNT(*) FROM users WHERE age > 30;  -- 100

[Параллельно]
  Транзакция 2:
    BEGIN;
    INSERT INTO users (name, age) VALUES ('Боб', 35);
    COMMIT;  -- Успешно

  Транзакция 1 пытается:
  INSERT INTO users (name, age) VALUES ('Алиса', 25);
  COMMIT;
  -- ОШИБКА: ошибка сериализации
  -- PostgreSQL отменил транзакцию 1
```

**Когда использовать:**
- Для критичных финансовых операций
- Когда абсолютно нужна консистентность
- Когда готов обрабатывать ошибки сериализации

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN;
  -- Твой код
COMMIT;  -- Может быть отменён с ошибкой сериализации
```


## Сравнительная таблица
---

| Аномалия | Read Committed | Repeatable Read | Serializable |
|---|---|---|---|
| Грязное чтение | Нет | Нет | Нет |
| Неповторяемое чтение | Да | Нет | Нет |
| Фантомное чтение | Да | Да | Нет |
| Ошибка сериализации | Нет | Возможна | Возможна |


## Практический пример: выбор уровня
---

```sql
-- 1. Обычное приложение (веб, API)
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
BEGIN;
  SELECT balance FROM accounts WHERE id = 1;
  UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;

-- 2. Перевод денег (требует консистентности)
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;
  SELECT balance FROM accounts WHERE id = 1;  -- Берётся снимок
  SELECT balance FROM accounts WHERE id = 2;
  UPDATE accounts SET balance = balance - 100 WHERE id = 1;
  UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;

-- 3. Финансовая операция (максимальная безопасность)
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN;
  SELECT SUM(balance) FROM accounts WHERE type = 'checking';
  UPDATE accounts SET balance = balance + interest WHERE type = 'checking';
COMMIT;
-- Приложение должно перезапустить если будет ошибка 40001
```


## Вопросы для самопроверки
---

1. Сколько уровней изоляции определяет SQL стандарт и сколько реально реализует PostgreSQL?
2. Почему Read Uncommitted в PostgreSQL эквивалентен Read Committed?
3. В чём разница между Read Committed и Repeatable Read?
4. Что такое неповторяемое чтение? Приведи пример.
5. Почему Serializable уровень может привести к ошибкам сериализации?
6. Какой уровень использовать для обычного веб-приложения и почему?

---

**[← Назад к PostgreSQL](../)**