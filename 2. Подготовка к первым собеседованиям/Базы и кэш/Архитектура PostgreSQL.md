---
layout: default
title: Архитектура PostgreSQL
permalink: /interview-prep/databases-cache/postgresql/architecture/
---
# Цель
---
Здесь ты разберёшься, как устроен PostgreSQL изнутри: процессы, память, хранение данных. Это фундамент для понимания оптимизации и решения проблем производительности.

# Материалы
---
Рекомендую прочитать документацию про архитектуру PostgreSQL.

[Документация по архитектуре](https://postgrespro.ru/docs/postgresql/current/runtime-config)


## Общая архитектура: процессы и память
---

PostgreSQL использует **процессную архитектуру** (в отличие от потоковой, как в MySQL). Каждое клиентское соединение порождает отдельный серверный процесс. Это обеспечивает изоляцию, но требует больше ресурсов.

**Главные процессы:**

1. **postmaster** — главный процесс PostgreSQL, запускается при старте БД:
   - Прослушивает входящие соединения
   - Создаёт новый процесс для каждого нового клиента
   - Управляет фоновыми процессами

2. **backend process** — процесс, обслуживающий конкретного клиента:
   - Работает независимо от других
   - Имеет собственную локальную память
   - Выполняет запросы этого клиента

3. **Фоновые процессы**:
   - **autovacuum** — запускает автоматическую очистку
   - **checkpointer** — выполняет контрольные точки
   - **walwriter** — записывает WAL (журнал предзаписи)
   - **bgwriter** — вытесняет грязные страницы буфера на диск


## Память в PostgreSQL
---

PostgreSQL использует трёхуровневую модель памяти:

**1. Общая память (Shared Memory)**

Выделяется при запуске сервера и используется всеми процессами:

- **shared_buffers** — кеш страниц БД. По умолчанию 128 МБ. Типичное значение: 25% от доступной памяти.
- **wal_buffers** — буфер для журнала предзаписи. Типичное значение: 16 МБ.

```sql
-- Проверить текущие настройки памяти
SHOW shared_buffers;
SHOW wal_buffers;
```

**2. Локальная память процесса**

Каждый backend процесс имеет свою память:

- **work_mem** — используется для сортировок и хеш-таблиц. По умолчанию 4 МБ.
- **maintenance_work_mem** — для операций поддержки (VACUUM, CREATE INDEX). По умолчанию 64 МБ.

```sql
-- Временно увеличить память для сортировки
SET work_mem = '256MB';
SELECT * FROM large_table ORDER BY expensive_column;
RESET work_mem;
```


## Структура хранения данных
---

PostgreSQL хранит данные в **страницах** размером 8 КБ. Каждая таблица состоит из множества страниц.

**Файловая структура:**

```
$PGDATA/
├── base/                  # Директория с базами данных
│   ├── 1/                 # Шаблонная БД
│   ├── 16384/             # Твоя база данных (OID)
│   │   ├── 1663           # Файл таблицы
│   │   └── индексы
├── pg_wal/                # Журнал предзаписи (WAL)
└── postgresql.conf        # Конфигурация
```


## Write-Ahead Logging (WAL)
---

**WAL** — механизм для надёжности. Перед тем как изменить данные на диске, PostgreSQL записывает эти изменения в журнал.

**Как это работает:**

1. Транзакция выполняет UPDATE
2. Изменения записываются в WAL на диск
3. Буферы обновляются в памяти
4. При COMMIT транзакция фиксируется в WAL
5. Фоновый процесс позже записывает данные на основное хранилище

**Почему это важно:**

- **Восстановление после сбоя**: если БД упадёт, WAL позволяет восстановить все завершённые транзакции
- **Репликация**: WAL можно отправлять на другой сервер для репликации


## Checkpoint: синхронизация с диском
---

**Checkpoint** — процесс, при котором все изменённые страницы в буфере записываются на диск.

```sql
-- Принудительно выполнить checkpoint
CHECKPOINT;

-- Посмотреть конфигурацию
SHOW checkpoint_timeout;  -- Интервал между checkpoint (обычно 5 мин)
```

Слишком частые checkpoint — нагрузка на диск. Слишком редкие — долгое восстановление после сбоя.


## Основные параметры конфигурации
---

```sql
-- Основные для производительности:
SHOW shared_buffers;        -- Обычно 25% RAM
SHOW effective_cache_size;  -- Подсказка для планировщика (50-75% RAM)
SHOW work_mem;              -- Память на сортировку
SHOW maintenance_work_mem;  -- Память для VACUUM/INDEX
```


## Вопросы для самопроверки
---

1. Чем отличается процессная архитектура PostgreSQL от потоковой?
2. Какова роль shared_buffers и какой параметр его контролирует?
3. Что такое WAL и почему он критичен для надёжности?
4. Как устроен Checkpoint и почему его частота влияет на производительность?
5. Какой параметр контролирует память для сортировки?

---

**[← Назад к PostgreSQL](../)**