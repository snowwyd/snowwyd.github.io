---
layout: default
title: Партиционирование и масштабирование
permalink: /interview-prep/databases-cache/kafka/partitioning/
---

# Цель
---

Разделы — это ДНК Kafka. Вся мощь масштабируемости приходит из умного партиционирования. Это отдельный уровень мышления, который отличает junior от middle разработчика.

# Материалы
---
## Зачем нужны разделы?
---

Представьте тему без разделов. Тогда:
- Только один брокер может хранить всю тему
- Только один потребитель может читать (нет параллелизма)
- Узкое место гарантировано

**С разделами**:
```
Тема: заказы (4 раздела)
├─ Раздел 0 на Брокере 1
├─ Раздел 1 на Брокере 2
├─ Раздел 2 на Брокере 3
└─ Раздел 3 на Брокере 1

Группа потребителей A:
├─ Потребитель 1 читает Раздел 0 и 1 параллельно
├─ Потребитель 2 читает Раздел 2 параллельно
└─ Потребитель 3 читает Раздел 3 параллельно
```

Теперь у вас есть **параллелизм**, **масштабируемость** и **надежность**.

## Выбор количества разделов
---

Это одна из самых важных design decisions в Kafka. Неправильный выбор = проблемы.

### Формула для подсчета (приблизительно)

```
желаемая_пропускная_способность = целевая_пропускная_способность_МБ_в_сек
пропускная_способность_раздела = пропускная_способность_потребителя_МБ_в_сек
количество_разделов = желаемая_пропускная_способность / пропускная_способность_раздела
```

**Пример**:
- Нужно обработать 100 МБ/сек
- Один потребитель может обработать 10 МБ/сек
- Нужно 100 / 10 = 10 разделов

Потом добавьте 30-50% для запаса:
- 10 * 1.5 = 15 разделов

### Другие факторы

**Время хранения**:
- Более длительное хранение → больше разделов (чтобы данные занимали меньше места на одном брокере)

**Коэффициент репликации**:
- Каждый раздел занимает место на коэффициент_репликации брокерах
- 100 разделов с коэффициент_репликации=3 занимает место как 300 логических разделов

**Требования latency производителя**:
- Меньше разделов = ниже latency (меньше координации)
- Больше разделов = выше latency (больше работы на координаторе)

**Требования упорядочения**:
- Если нужен глобальный порядок = 1 раздел (но это убивает масштабируемость)
- Если нужен порядок per сущность = используйте ключ раздела

## Стратегия ключа раздела
---

Это самая важная часть! Выбор ключа раздела определяет как распределяются ваши данные.

### Опция 1: Без ключа (key=null)
```go
writer.WriteMessages(ctx, kafka.Message{
    Value: []byte("некоторые данные"),
    // Ключ не указан!
})
```
- Round-robin (или липкий в новых версиях)
- Данные распределяются равномерно
- ❌ Потеря порядка (даже для одного пользователя)

### Опция 2: Ключ = идентификатор_пользователя
```go
writer.WriteMessages(ctx, kafka.Message{
    Key:   []byte("пользователь-123"),
    Value: []byte(`{"действие": "вход"}`),
})
```
- Все события пользователя в один раздел
- ✅ Порядок гарантирован для пользователя
- ✅ Упрощает обработку с состоянием
- Может быть дисбаланс если у одного пользователя много событий

### Опция 3: Ключ = идентификатор_заказа
```go
writer.WriteMessages(ctx, kafka.Message{
    Key:   []byte("заказ-abc-123"),
    Value: []byte(`{"статус": "оплачен"}`),
})
```
- Все события одного заказа в один раздел
- ✅ Можно обработать заказ атомарно
- ✅ Не нужна распределенная транзакция

### Опция 4: Составной ключ
```go
ключ := fmt.Sprintf("%s:%s", идентификатор_клиента, идентификатор_товара)
writer.WriteMessages(ctx, kafka.Message{
    Key:   []byte(ключ),
    Value: []byte(данные),
})
```
- Дает больше контроля
- Может помочь с балансом между порядком и распределением

## Проблема горячего раздела
---

Это когда один раздел получает НАМНОГО больше трафика чем другие.

**Пример** (плохо):
```
Ключ раздела = идентификатор_страны

✅ Раздел 0 (США): 1000 сообщений/сек
✅ Раздел 1 (Великобритания):  300 сообщений/сек
❌ Раздел 2 (Россия):  50 сообщений/сек → ГОРЯЧИЙ!
   Но большинство пользователей из России...
```

Один брокер сильно нагружен, другие недоиспользованы.

**Решение**:
1. **Изменить ключ**: Вместо идентификатор_страны, использовать `идентификатор_страны:идентификатор_пользователя`
2. **Добавить больше разделов**: Пересчитается хеширование, данные перераспределятся (но это требует переназначения)
3. **Временное разделение**: Добавить временную метку в ключ для разделения нагрузки

## Стратегии назначения потребителей
---

Как Kafka распределяет разделы между потребителями?

### Range (диапазон)

```
Тема: заказы (10 разделов)
Потребители: потребитель1, потребитель2, потребитель3

Назначение диапазоном:
- потребитель1: Раздел 0, 1, 2, 3
- потребитель2: Раздел 4, 5, 6, 7
- потребитель3: Раздел 8, 9
```

Если добавиться потребитель4:
```
- потребитель1: Раздел 0, 1
- потребитель2: Раздел 2, 3, 4, 5
- потребитель3: Раздел 6, 7, 8
- потребитель4: Раздел 9
```

**Плюсы**: Простота, совместное размещение разделов разных тем
**Минусы**: Может быть дисбаланс

### Round-Robin (круговое распределение)

```
- потребитель1: Раздел 0, 3, 6, 9
- потребитель2: Раздел 1, 4, 7
- потребитель3: Раздел 2, 5, 8
```

**Плюсы**: Более сбалансировано
**Минусы**: Нарушает совместное размещение для разных тем

### Sticky (липкое)

Гибридный подход: старайтесь сбалансировать, но избегайте излишних перестановок.

## Типичные вопросы собеседования
---

**В: Как изменить количество разделов для существующей темы?**
О: `kafka-topics --alter --topic заказы --partitions 20`. Данные НЕ пересчитаны! Новые сообщения распределяться по новым разделам по новой хеш-функции. Старые остаются на старых. Это может нарушить семантику ключей.

**В: Может ли сообщение попасть в разные разделы если я изменил ключ на лету?**
О: Да. Если раньше отправляли ключ=идентификатор_пользователя, потом поменяли на ключ=идентификатор_пользователя:временная_метка, хеши будут разные. Порядок нарушится.

**В: Как гарантировать идеальную балансировку нагрузки?**
О: Нельзя гарантировать если данные имеют естественный перекос (некоторые пользователи более активны). Используйте пользовательский распределитель для динамической балансировки.

**В: Что если у меня 10 разделов и 100 потребителей?**
О: 90 потребителей будут без работы (безработные). Это стоит денег и ничего не дает. Максимум потребителей = количество разделов.

---

**[← Назад к Kafka](../)**