---
layout: default
title: Введение в Redis и базовая архитектура
permalink: /interview-prep/databases-cache/redis/architecture/
---
# Цель
---
Понять что такое Redis, как он работает на уровне памяти и архитектуры, и почему именно это делает его таким быстрым. Эта информация критична для понимания всех остальных концепций Redis.

# Материалы
---

## Что такое Redis?
---
**Redis (REmote DIctionary Server)** — это **open-source, in-memory data structure store**, который используется как:

- **Cache**: самый частый use-case
- **Session store**: для веб-приложений
- **Message broker**: через Pub/Sub или Streams
- **Real-time leaderboards**: используя sorted sets
- **Rate limiter**: для throttling
- **Distributed lock manager**: для синхронизации сервисов

Главное отличие Redis от традиционных БД вроде PostgreSQL: **Redis работает полностью в памяти (RAM)**. Это означает, что скорость доступа — это скорость работы с памятью, измеряемая в микросекундах, а не миллисекундах как в дисковых БД.

## Архитектура Redis: Single-Threaded Event Loop
---
Один из самых важных фактов про Redis: **он single-threaded**. Все команды обрабатываются в одном потоке, последовательно. Это может звучать как недостаток, но это даёт огромные преимущества.

### Как это работает:

```
Клиент 1 → | SET key1 value1 |
            |  ↓ Event Loop   | → ✓ OK
            | GET key2        |
Клиент 2 → | ↓ (очередь)     | → value2
            | DEL key3        |
Клиент 3 → | ↓               | → (integer) 1
            |________________|
```

Все команды от всех клиентов попадают в одну очередь и обрабатываются **поочередно**, в порядке поступления. Это означает:

1. **Атомарность операций**: Если операция началась, ничто другое не прерывает её выполнение
2. **Предсказуемость**: Нет race conditions при работе с одним ключом
3. **Производительность**: Не нужно следить за блокировками, нет overhead'а на переключение контекста между потоками

### Почему это работает так быстро:

- **В памяти**: Доступ в RAM — это ~100 нанесекунды, дисковые БД — это миллисекунды
- **Оптимизированные структуры данных**: Skip lists для sorted sets, hash tables, linked lists — всё оптимизировано на скорость
- **Асинхронный I/O**: Использует epoll/kqueue для обработки множества клиентских соединений
- **Batching**: С помощью pipelining ты можешь отправить много команд за раз

## Базовые типы данных
---
Redis поддерживает несколько простых типов:

### 1. Strings (Строки)

Самый базовый тип — просто последовательность байтов.

```redis
SET user:1000:name "Ivan"
GET user:1000:name

SET counter 0
INCR counter          # атомарно увеличивает
INCRBY counter 5      # добавляет 5
```

**Важно**: Strings в Redis — это binary-safe. Это означает, что они могут содержать любые данные: текст, числа, сериализованные объекты (JSON, Protocol Buffers и т.д.).

### 2. Numbers

Специальный случай strings. Если содержимое выглядит как число, Redis позволяет атомарно выполнять арифметику:

```redis
SET page_views 0
INCR page_views       # = 1
INCR page_views       # = 2
DECR page_views       # = 1
```

Это **атомарно** даже с множеством клиентов. Redis гарантирует что два `INCR` не переписывают друг друга.

### 3. Binary Data

```redis
SET image:1 <binary_data_here>
GET image:1
```

Redis не заботится что находится в string. Ты можешь положить туда сериализованный объект.

## TTL и Expiration
---
Один из самых мощных и часто неправильно используемых feature'ов Redis.

Любой ключ может иметь **Time-To-Live** — время через которое ключ автоматически удалится:

```redis
SET session:abc123 "{user_id: 42}"
EXPIRE session:abc123 3600        # удалится через час

# или в одной команде:
SETEX session:abc123 3600 "{user_id: 42}"

# проверить TTL:
TTL session:abc123                # вернёт количество секунд
PTTL session:abc123               # в миллисекундах
```

### Как это работает:

Redis **не удаляет ключ ровно в момент expiration**. Это была бы очень неэффективно. Вместо этого Redis использует две стратегии:

1. **Passive eviction**: Когда ты делаешь GET на ключ с истекшим TTL, Redis видит что он expired и удаляет его
2. **Active eviction**: Фоновый процесс периодически сканирует ключи и удаляет expired

Практическое следствие: **Если ты никогда не читаешь expired ключ, он может жить в памяти дольше чем рассчитано**. Но это редко проблема.

### Практический пример: Session storage

```redis
# Пользователь логинится
SET session:user123 "{...session_data...}"
EXPIRE session:user123 1800

# Пользователь делает запрос через 10 минут
GET session:user123                 # ✓ OK, вернёт данные

# Если пользователь ничего не делал 31 минуту
GET session:user123                 # ✗ nil, сессия истекла
```

## Memory Model
---
Важно понимать как Redis хранит данные в памяти.

### Базовая структура:

```
Redis Memory
├── Dictionary (основная hash table)
│   ├── "user:1000" → <значение>
│   ├── "user:1001" → <значение>
│   └── "counter"   → <значение>
├── Expiry Dictionary
│   ├── "user:1000" → <timestamp>
│   └── "user:1001" → <timestamp>
└── Internal Data Structures
    ├── Lists (linked lists)
    ├── Sets (hash sets)
    ├── Hashes (nested hash tables)
    └── Sorted Sets (skip lists)
```

**Размер ключа**: Каждый ключ хранится в основной dictionary. Это означает что если у тебя миллион ключей, даже если каждый ключ маленький, памяти уйдёт на хранение миллиона записей в dictionary.

**Размер значения**: Зависит от типа. String занимает столько сколько нужно для хранения данных. List/Set/Hash/Sorted Set занимают больше памяти чем простые strings.

## Базовые команды
---
### Работа со строками:

```redis
SET key value              # установить значение
GET key                    # получить значение
DEL key1 key2              # удалить ключи
EXISTS key                 # проверить существование
INCR counter               # атомично увеличить (если число)
APPEND key "suffix"        # добавить к строке
STRLEN key                 # длина строки
```

### Работа с ключами:

```redis
KEYS *                     # получить все ключи (⚠️ опасно в production!)
KEYS user:*                # по паттерну
RANDOMKEY                  # случайный ключ
RENAME key newkey          # переименовать
TYPE key                   # получить тип (string, list, set, etc.)
```

### Проверка памяти:

```redis
DBSIZE                     # количество ключей в текущей БД
INFO memory                # подробная информация о памяти
MEMORY USAGE key           # сколько памяти использует ключ
```

## Connection и Protocol
---
Redis использует простой текстовый протокол RESP (Redis Serialization Protocol).

### Пример:

```
# Отправляем:
*3\r\n$3\r\nSET\r\n$4\r\nkey1\r\n$6\r\nvalue1\r\n

# Redis отвечает:
+OK\r\n
```

Хорошая новость: ты не пишешь это руками. Клиентские библиотеки (redis-py, redis-go, etc.) это всё оборачивают.

### Connection Pooling

В production ты никогда не создаёшь новое соединение для каждой команды. Вместо этого используешь connection pool:

```go
// Пример на Go
pool := &redis.ConnectionPool{
    MaxIdle: 10,
    MaxActive: 100,
}

conn := pool.Get()      // переиспользуемое соединение
defer conn.Close()      // возвращается в пул
```

Это критично для производительности. Создание нового TCP соединения — это дорого.

## Мониторинг базовых метрик
---
Чтобы понять здоров ли Redis:

```redis
# Всё что нужно знать про Redis:
INFO all

# Только про память:
INFO memory

# Только про статистику команд:
INFO stats

# Только про репликацию:
INFO replication
```

Выход INFO содержит кучу полезного:

- `used_memory`: сколько памяти используется
- `connected_clients`: сколько клиентов подключено
- `total_commands_processed`: всего команд выполнено
- `instantaneous_ops_per_sec`: команд в секунду прямо сейчас

## Важные особенности
---
### 1. Redis потеряет данные при перезагрузке (по умолчанию)

Redis хранит всё в памяти. Если процесс упадёт, все данные потеряются. Можно включить persistence (RDB или AOF), но по умолчанию — это не включено.

### 2. Все данные нужны в памяти

Не можешь иметь 1TB данных если у тебя только 10GB RAM. Redis не может spillать на диск как обычная БД.

### 3. В памяти всё очень быстро

Даже O(N) операция на 1 миллион элементов обычно выполняется за несколько миллисекунд.

### 4. Операции атомарные на уровне одной команды

`SET key value` — атомарна. `GET key` — атомарна. Но если тебе нужна атомарность нескольких команд, нужны транзакции (MULTI/EXEC) или Lua scripting.

---

## Когда использовать Redis?

✅ **Хорошие use-case'ы:**
- Кэширование результатов запросов к БД
- Session storage
- Real-time counters (page views, likes, etc.)
- Leaderboards
- Rate limiting
- Job queues
- Pub/Sub для notifications

❌ **Плохие use-case'ы:**
- Primary data store для критичных данных (без persistence)
- Очень большие наборы данных что не влезают в памяти
- Данные которые нужно долго хранить (используй БД)
- Когда нужна сложная логика запросов (используй SQL)

## Следующие шаги
---
Теперь когда ты понимаешь основы архитектуры, пора разобраться с конкретными структурами данных и их use-case'ами. Каждая структура разработана для решения конкретных проблем, и неправильный выбор может привести к O(N) вместо O(1).

---

**[← Назад к Redis](../)**