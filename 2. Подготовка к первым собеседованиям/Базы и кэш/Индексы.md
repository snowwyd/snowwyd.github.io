---
layout: default
title: Типы индексов
permalink: /interview-prep/databases-cache/postgresql/indexes/
---

# Цель
---
Здесь ты разберёшься с типами индексов в PostgreSQL и когда какой использовать. Правильно спроектированные индексы могут ускорить запросы в сотни раз. Это одна из ключевых тем для Middle разработчика.

# Материалы
---
Рекомендую прочитать документацию по индексам.

[Документация по индексам](https://postgrespro.ru/docs/postgresql/current/indexes)


## Зачем нужны индексы?
---

Без индекса PostgreSQL вынужден выполнить **Seq Scan** — прочитать все строки таблицы. Это медленно.

С индексом PostgreSQL может использовать **Index Scan** — прыгать прямо к нужным строкам.

```sql
-- Без индекса: читает все 1 000 000 строк
EXPLAIN SELECT * FROM users WHERE id = 42;
-- Seq Scan on users  (cost=0.00..35000.00 rows=1000000)

-- С индексом: читает только нужные строки
CREATE INDEX users_id_idx ON users(id);
EXPLAIN SELECT * FROM users WHERE id = 42;
-- Index Scan using users_id_idx on users  (cost=0.29..8.30 rows=1)
```


## 1. B-tree (по умолчанию)
---

**Когда использовать:** для равенства (=) и диапазонов (<, >, <=, >=, BETWEEN).

**Структура:** сбалансированное дерево. Листья отсортированы, поэтому хорошо для диапазонов.

```sql
-- Создание B-tree индекса
CREATE INDEX users_email_idx ON users(email);

-- Эффективно:
SELECT * FROM users WHERE email = 'test@example.com';     -- равенство
SELECT * FROM users WHERE email LIKE 'test%';             -- LIKE с префиксом
SELECT * FROM users WHERE created_at > '2025-01-01';      -- диапазон
SELECT * FROM users WHERE id BETWEEN 100 AND 200;         -- диапазон
SELECT * FROM users WHERE age < 30 ORDER BY age;          -- ORDER BY

-- Неэффективно:
SELECT * FROM users WHERE email LIKE '%test%';            -- LIKE без префикса
SELECT * FROM users WHERE LOWER(email) = 'test@example.com';  -- Функция на колонке
```

**Плюсы:**
- Универсален, подходит для большинства случаев
- Эффективен для диапазонов
- Поддерживает ORDER BY

**Минусы:**
- Требует памяти и места на диске
- Замедляет INSERT/UPDATE/DELETE


## 2. Hash
---

**Когда использовать:** только для проверки равенства (=). Редко используется.

```sql
CREATE INDEX users_id_hash ON users USING HASH(id);

-- Эффективно:
SELECT * FROM users WHERE id = 42;

-- Неэффективно:
SELECT * FROM users WHERE id > 100;    -- Не работает с диапазонами
SELECT * FROM users ORDER BY id;       -- Не поддерживает ORDER BY
```

**На практике:** Hash индексы редко используются. B-tree обычно лучше.


## 3. GIN (обобщённый обратный индекс)
---

**Когда использовать:** для поиска в **сложных типах данных**: JSON, массивы, полнотекстовый поиск.

**Поиск в JSON:**

```sql
CREATE TABLE orders (
  id INT,
  data JSONB
);

CREATE INDEX orders_data_gin ON orders USING GIN(data);

-- Эффективно с GIN индексом:
SELECT * FROM orders WHERE data @> '{"status": "completed"}';
```

**Поиск в массивах:**

```sql
CREATE TABLE tags (
  id INT,
  tags TEXT[]
);

CREATE INDEX tags_gin ON tags USING GIN(tags);

-- Эффективно:
SELECT * FROM tags WHERE tags @> ARRAY['python'];  -- Содержит python
```

**Плюсы:**
- Очень быстро для сложных типов данных
- Поддерживает операции @>, &&, @@

**Минусы:**
- Медленнее чем B-tree для простых типов
- Требует больше памяти


## 4. BRIN (индекс диапазонов блоков)
---

**Когда использовать:** для **больших таблиц с отсортированными данными** (временные ряды, логи).

**Структура:** делит таблицу на блоки и хранит минимум/максимум для каждого блока.

```sql
CREATE TABLE server_logs (
  id BIGINT,
  timestamp TIMESTAMP,
  message TEXT
);

-- BRIN индекс очень компактный
CREATE INDEX logs_timestamp_brin ON server_logs USING BRIN(timestamp);

-- Эффективно для временных рядов:
SELECT * FROM server_logs 
WHERE timestamp > '2025-01-01' AND timestamp < '2025-01-31';
```

**Пример размера для 1 миллиарда логов:**
- B-tree индекс: ~20 ГБ памяти
- BRIN индекс: ~10 МБ памяти (в 2000 раз меньше!)

**Плюсы:**
- Очень мало памяти
- Отлично для отсортированных больших данных

**Минусы:**
- Медленнее чем B-tree для точных поисков
- Работает только если данные отсортированы


## Составные индексы
---

Индекс по нескольким столбцам может быть очень эффективным:

```sql
CREATE INDEX users_email_created_idx ON users(email, created_at);

-- Эффективно (используется индекс):
SELECT * FROM users WHERE email = 'test@example.com' AND created_at > '2025-01-01';

-- Эффективно (левая часть индекса):
SELECT * FROM users WHERE email = 'test@example.com';

-- НЕЭФФЕКТИВНО (нет левой части):
SELECT * FROM users WHERE created_at > '2025-01-01';  -- Индекс не используется!
```

**Важно:** порядок колонок в составном индексе критичен. Левая часть должна быть в запросе.


## Частичные индексы
---

Индекс только на подмножество строк:

```sql
-- Индекс только для активных пользователей
CREATE INDEX users_active_email_idx ON users(email)
WHERE status = 'active';

-- Экономим память, индекс компактнее
SELECT * FROM users WHERE email = 'test@example.com' AND status = 'active';
```


## Индексы по выражениям
---

```sql
-- Индекс по функции
CREATE INDEX users_email_lower_idx ON users(LOWER(email));

-- Теперь эффективно:
SELECT * FROM users WHERE LOWER(email) = 'test@example.com';
```


## Управление индексами
---

```sql
-- Посмотреть все индексы таблицы
\d users
SELECT * FROM pg_indexes WHERE tablename = 'users';

-- Размер индекса
SELECT pg_size_pretty(pg_relation_size('users_email_idx'));

-- Неиспользуемые индексы (кандидаты на удаление)
SELECT indexname 
FROM pg_stat_user_indexes 
WHERE idx_scan = 0;

-- Удалить индекс
DROP INDEX users_email_idx;
```


## Когда НЕ использовать индексы
---

1. **На маленьких таблицах** (<1000 строк) — индекс медленнее чем Seq Scan
2. **На колонках с низкой кардинальностью** (мало уникальных значений):
   ```sql
   -- Плохо: только 2 уникальных значения
   CREATE INDEX users_gender_idx ON users(gender);  -- 'М' или 'Ж'
   ```
3. **На часто обновляемых колонках** — индекс замедлит UPDATE


## Вопросы для самопроверки
---

1. Какой индекс по умолчанию создаёт CREATE INDEX?
2. Когда использовать B-tree, а когда GIN?
3. Когда использовать BRIN?
4. Что такое составной индекс и почему важен порядок колонок?
5. Как найти неиспользуемые индексы?
6. Когда индекс может замедлить запрос?

---

**[← Назад к PostgreSQL](../)**