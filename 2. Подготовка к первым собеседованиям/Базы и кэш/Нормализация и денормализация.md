---
layout: default
title: Нормализация и денормализация
permalink: /interview-prep/databases-cache/postgresql/normalization/
---

# Цель
---
Здесь ты разберёшься с нормализацией и денормализацией — как правильно проектировать структуру базы данных. Нормализация минимизирует избыточность, денормализация оптимизирует производительность.

# Материалы
---
Рекомендую изучить теорию нормальных форм и практику проектирования.


## Нормализация: формы нормализации
---

### 1NF (Первая нормальная форма)

**Правило:** каждая колонка содержит только атомарные (неделимые) значения.

**Плохо:**

```sql
CREATE TABLE employees (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  phone_numbers VARCHAR(255)  -- '555-1234, 555-5678' в одной колонке
);
```

**Хорошо:**

```sql
CREATE TABLE employees (
  id INT PRIMARY KEY,
  name VARCHAR(100)
);

CREATE TABLE employee_phones (
  id INT PRIMARY KEY,
  employee_id INT REFERENCES employees(id),
  phone_number VARCHAR(20)
);
```


### 2NF (Вторая нормальная форма)

**Правило:** в 1NF + нет неключевых атрибутов, зависящих от части составного ключа.

**Плохо:**

```sql
CREATE TABLE orders (
  order_id INT,
  product_id INT,
  product_name VARCHAR(100),  -- Зависит от product_id, не от обоих ключей
  quantity INT,
  PRIMARY KEY (order_id, product_id)
);
```

**Хорошо:**

```sql
CREATE TABLE orders (
  order_id INT PRIMARY KEY,
  customer_id INT
);

CREATE TABLE order_items (
  order_id INT,
  product_id INT,
  quantity INT,
  PRIMARY KEY (order_id, product_id)
);

CREATE TABLE products (
  id INT PRIMARY KEY,
  name VARCHAR(100)
);
```


### 3NF (Третья нормальная форма)

**Правило:** в 2NF + нет транзитивных зависимостей (неключевой атрибут зависит от другого неключевого атрибута).

**Плохо:**

```sql
CREATE TABLE employees (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  department_id INT,
  department_name VARCHAR(100)  -- Зависит от department_id, не от id
);
```

**Хорошо:**

```sql
CREATE TABLE departments (
  id INT PRIMARY KEY,
  name VARCHAR(100)
);

CREATE TABLE employees (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  department_id INT REFERENCES departments(id)
);
```


## Преимущества нормализации
---

- **Минимизация избыточности** — данные хранятся один раз
- **Целостность данных** — нет противоречивых данных
- **Правильное обновление** — UPDATE требует изменения только в одном месте
- **Гибкость** — легко добавлять новые данные


## Недостатки нормализации
---

- **Много JOIN** — нужно соединять много таблиц для одного запроса
- **Медленность** — JOIN дороже чем чтение из одной таблицы
- **Сложность** — запросы становятся сложнее


## Денормализация
---

**Денормализация** — это контролируемое введение избыточности для оптимизации производительности.

**Когда денормализировать:**
- Нагрузка на чтение намного больше, чем на запись
- Сложные аналитические запросы с множеством JOIN
- Нужна максимальная скорость для real-time систем
- Кеширование вычисляемых значений (COUNT, SUM)


## Примеры денормализации
---

**Пример 1: Кеширование COUNT**

```sql
-- Нормализованная схема: медленно
SELECT COUNT(*) FROM order_items WHERE order_id = 1;

-- Денормализованная: быстро
CREATE TABLE orders (
  id INT PRIMARY KEY,
  customer_id INT,
  item_count INT,  -- Кешируем количество товаров
  total_amount DECIMAL
);

-- Обновляем через триггер
CREATE OR REPLACE FUNCTION update_item_count()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE orders SET item_count = item_count + 1 WHERE id = NEW.order_id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Теперь COUNT мгновенный:
SELECT item_count FROM orders WHERE id = 1;
```

**Пример 2: Копирование данных**

```sql
-- Нормализованная: JOIN каждый раз
SELECT u.name, o.total, o.created_at
FROM users u
JOIN orders o ON u.id = o.user_id;

-- Денормализованная: без JOIN
CREATE TABLE orders (
  id INT PRIMARY KEY,
  customer_id INT,
  customer_name VARCHAR(100),  -- Копируем из users
  total DECIMAL,
  created_at TIMESTAMP
);

-- Теперь без JOIN:
SELECT customer_name, total, created_at FROM orders;
```


## Стратегии денормализации
---

**1. Триггеры для поддержания консистентности**

```sql
CREATE OR REPLACE FUNCTION update_product_category()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.category_id != OLD.category_id THEN
    SELECT name INTO NEW.category_name 
    FROM categories WHERE id = NEW.category_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

**2. Материализованные представления**

```sql
CREATE MATERIALIZED VIEW user_order_stats AS
SELECT 
  u.id as user_id,
  u.name,
  COUNT(o.id) as order_count,
  SUM(o.amount) as total_spent
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;

-- Периодически обновляем
REFRESH MATERIALIZED VIEW user_order_stats;
```


## Рекомендации
---

| Критерий | Нормализация | Денормализация |
|----------|--------------|----------------|
| Запросы на чтение | Могут быть сложными | Простые и быстрые |
| Обновления | Быстрые | Могут быть медленными |
| Место на диске | Меньше | Больше |
| Архитектура | OLTP | OLAP, аналитика |

**Практический совет:** начни с нормализации 3NF, затем денормализируй только то, что необходимо для оптимизации.


## Вопросы для самопроверки
---

1. Что такое нормализация и зачем она нужна?
2. В чём разница между 2NF и 3NF?
3. Когда нужна денормализация?
4. Как кешировать COUNT с денормализацией?
5. Что лучше: денормализация или MATERIALIZED VIEW?
6. Какая нормальная форма используется в большинстве приложений?

---

**[← Назад к PostgreSQL](../)**