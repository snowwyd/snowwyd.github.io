---
layout: default
title: Consumer - полный разбор
permalink: /interview-prep/databases-cache/kafka/consumer/
---

# Цель
---
Если Producer отправляет, то Consumer читает. Это вторая половина уравнения. Потребитель — это самая сложная часть Kafka, где происходит магия с переназначением, отставанием и группами потребителей.

# Материалы
---
## Что такое Consumer Group?
---
**Consumer Group** — это ключевая концепция в Kafka. Это позволяет масштабировать потребление.

**Как это работает**:
1. Несколько потребителей объединяются в группу (указывая одинаковый `group.id`)
2. Kafka автоматически распределяет разделы между ними
3. Каждое сообщение доставляется ровно одному потребителю в группе
4. Если один потребитель упадет, его разделы переходят к другим

**Пример**:
```
Topic: заказы (10 разделов)
Группа потребителей A:
├─ Потребитель 1 → Раздел 0, 1, 2, 3
├─ Потребитель 2 → Раздел 4, 5, 6
└─ Потребитель 3 → Раздел 7, 8, 9
```

Если добавить еще одного потребителя:
```
Группа потребителей A (после добавления Потребителя 4):
├─ Потребитель 1 → Раздел 0, 1
├─ Потребитель 2 → Раздел 2, 3, 4, 5
├─ Потребитель 3 → Раздел 6, 7, 8
└─ Потребитель 4 → Раздел 9
```

**Что произошло?** Переназначение! Kafka пересчитал, как распределить разделы.

## Consumer Rebalancing (Переназначение разделов)
---

**Переназначение** — это процесс пересчета распределения разделов между потребителями.

**Когда происходит переназначение?**
- Добавился новый потребитель в группу
- Потребитель вышел из группы (крэш, корректное выключение)
- Изменилось число разделов в topic

**Что происходит во время переназначения?**
1. Все потребители в группе **останавливают** обработку сообщений
2. Каждый потребитель отправляет свое смещение в Kafka (для сохранения прогресса)
3. Назначенный потребитель (лидер) считает новое распределение разделов
4. Все потребители получают новое назначение
5. Каждый потребитель загружает смещения для новых разделов
6. Все возобновляют чтение

**Это дорогая операция!** На больших системах данных переназначение может занять минуты. Избегайте частых добавлений/удалений потребителей.

**На собеседовании**: 
> "Почему важно статическое членство в группе?"
> Ответ: "Если потребитель перезагружается, с обычным динамическим членством происходит переназначение. Статическое членство означает, что потребитель получит свои же разделы обратно без переназначения."

## Consumer Lag (Отставание)
---

**Consumer Lag** — это разница между последним смещением в разделе и смещением, который прочитал потребитель.

```
Раздел 0:
├─ Последнее смещение: 1000
└─ Смещение потребителя: 850
Отставание = 1000 - 850 = 150 сообщений
```

**Почему это важно?**
- Отставание потребителя показывает, как быстро вы обрабатываете сообщения
- Если отставание растет, значит производитель пишет быстрее чем потребитель обрабатывает
- Это главная метрика для мониторинга Kafka систем

**Мониторинг отставания**:
```bash
# Посмотреть отставание для группы
kafka-consumer-groups --bootstrap-server localhost:9092 \
  --group моя-группа \
  --describe
```

## Pull против Push модель
---

**Kafka использует PULL модель**. Это критично понимать.

### Push модель (RabbitMQ, некоторые очереди):
- Брокер активно отправляет сообщения потребителям
- Если потребитель медленный, может "залиться" сообщениями
- Брокер нужно знать пропускную способность потребителя

### Pull модель (Kafka):
- Потребитель сам просит сообщения: "Дай мне 100 сообщений"
- Потребитель контролирует скорость обработки
- Брокер просто хранит и отправляет что просят

**Преимущества Pull для Kafka**:
- Потребитель может обработать батч, потом запросить еще
- Дает контроль потребителю над пропускной способностью
- Работает лучше с батчингом и асинхронной обработкой

## Параметры выборки (Fetch)
---

### max.poll.records
- Максимум сообщений, которое потребитель получит в один вызов `poll()`
- По умолчанию: 500
- Если вы обрабатываете быстро, можно увеличить
- Если обработка медленная, уменьшите, чтобы не упустить таймаут сердцебиения

### fetch.min.bytes
- Минимум байт перед отправкой ответа
- По умолчанию: 1 байт
- Больший размер означает, что брокер будет ждать, пока накопится достаточно данных
- Компромисс: Меньше latency но ниже пропускная способность против Больше latency но выше пропускная способность

### fetch.max.wait.ms
- Максимальное время ожидания если данных меньше чем fetch.min.bytes
- По умолчанию: 500ms
- Если ничего не произойдет 500ms, вернет то что есть

## Координация потребителя
---

### Механизм сердцебиения (Heartbeat)

Потребитель должен регулярно отправлять сердцебиение:
- `heartbeat.interval.ms`: как часто отправлять сердцебиение (по умолчанию: 3s)
- `session.timeout.ms`: если сердцебиений нет дольше, потребитель считается мертвым (по умолчанию: 10s)
- `max.poll.interval.ms`: максимум времени между вызовами `poll()` (по умолчанию: 5 минут)

**Важно**: Если ваша обработка сообщения занимает дольше `max.poll.interval.ms`, Kafka выдаст вас за мертвого потребителя даже если вы живы.

## Типичные вопросы собеседования
---

**В: Что происходит если несколько потребителей подключились с разными group.id?**
О: Это разные группы потребителей. Каждая группа независимо читает все разделы темы. Два разных процесса обработки для одних и тех же данных.

**В: Как гарантировать, что сообщение обработано ровно один раз в группе потребителей?**
О: Использовать идемпотентную обработку (одинаковые входные данные дают одинаковый результат) + ручное фиксирование смещений. Отправить смещение в Kafka только ПОСЛЕ успешной обработки.

**В: Потребитель упал с ошибкой прямо после poll(), но ДО обработки сообщения. Что будет?**
О: С автофиксированием по умолчанию, смещение может быть уже зафиксировано. Другой потребитель начнет со следующего сообщения и пропустит это. Решение: отключить автофиксирование, обработать сообщение, потом зафиксировать.

**В: Как я знаю что я отстаю?**
О: Мониторьте отставание потребителя. Если оно растет - обработка медленнее чем производство. Добавьте потребителей или оптимизируйте обработку.

---

**[← Назад к Kafka](../)**