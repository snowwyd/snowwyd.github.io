---
layout: default
title: MVCC многоверсионность
permalink: /interview-prep/databases-cache/postgresql/mvcc/
---

# Цель
---
Здесь ты разберёшься с MVCC — механизмом многоверсионности, который является сердцем PostgreSQL. Это позволяет нескольким транзакциям одновременно читать и изменять данные без блокировок.

# Материалы
---
Рекомендую прочитать про MVCC в документации.

[Документация по MVCC](https://postgrespro.ru/docs/postgresql/current/mvcc)


## Ключевая идея: версионирование данных
---

В традиционных БД при UPDATE строка блокируется — читающие и пишущие транзакции ждут. Это медленно и приводит к взаимоблокировкам.

В PostgreSQL с MVCC:
- Писатель **не блокирует** читателя
- Читатель видит **снимок** данных на момент начала своей транзакции
- Писатель создаёт **новую версию** строки

**Пример:**

```
Исходное состояние: строка (xmin=100, xmax=NULL, name='Алиса')

Транзакция 1 (txid=200): UPDATE users SET name='Боб' WHERE id=1
├─ Создаётся новая версия: (xmin=200, xmax=NULL, name='Боб')
└─ Старая версия помечается: (xmin=100, xmax=200, name='Алиса')

Транзакция 2 (txid=150) читает эту строку:
├─ Видит только старую версию, так как начала ДО 200-й транзакции
└─ SELECT вернёт 'Алиса'

Транзакция 3 (txid=250) читает эту строку:
├─ Видит только новую версию, так как начала ПОСЛЕ 200-й транзакции
└─ SELECT вернёт 'Боб'
```


## Системные колонки: xmin и xmax
---

В PostgreSQL каждая строка имеет скрытые системные колонки:

- **xmin** — идентификатор транзакции, которая создала эту версию строки
- **xmax** — идентификатор транзакции, которая удалила/обновила эту версию (NULL если актуальна)
- **ctid** — физическое расположение строки (блок, смещение)

```sql
-- Посмотреть внутренние колонки
SELECT 
  ctid,
  xmin,
  xmax,
  name
FROM users;

-- Пример результата:
-- ctid  | xmin | xmax | name
-- ------+------+------+-------
-- (0,1) | 1000 | 1005 | Алиса (удалена)
-- (0,2) | 1005 | NULL | Боб   (текущая)
```


## Снимки транзакций
---

Каждая транзакция начинает со **снимка** — информации о том, какие транзакции были активны на момент начала.

Снимок содержит:
- **xmin** — минимальный идентификатор активной транзакции
- **xmax** — максимальный идентификатор активной транзакции
- **active_xids** — список всех активных транзакций

Когда читается строка, PostgreSQL проверяет:
1. Дата создания строки (xmin) завершена? → видима
2. Дата удаления строки (xmax) не установлена или не завершена? → видима
3. Иначе → не видима


## Жизненный цикл версии строки
---

```
1. INSERT (txid=100)
   ├─ xmin = 100
   ├─ xmax = NULL
   └─ Строка видна для всех txid > 100

2. UPDATE (txid=200)
   ├─ Старая версия: xmin=100, xmax=200
   ├─ Новая версия: xmin=200, xmax=NULL
   └─ Транзакции между 100 и 200 видят старую версию

3. VACUUM (autovacuum)
   ├─ Удаляет старые мёртвые версии
   └─ Остаётся только актуальная версия
```

Это называется **bloat** — на диске накапливаются мёртвые версии. VACUUM их удаляет.


## Преимущества и недостатки MVCC
---

**Преимущества:**
- Минимальные блокировки: читатели не блокируют писателей и наоборот
- Высокий параллелизм транзакций
- Консистентные снимки: каждая транзакция видит согласованный снимок БД

**Недостатки:**
- Bloat: старые версии строк занимают место на диске
- Долгие транзакции: если долгая транзакция остаётся открытой, она блокирует VACUUM
- Нужен регулярный VACUUM для очистки


## Долгие транзакции и проблемы
---

Долгая открытая транзакция может вызвать серьёзные проблемы:

```sql
-- Плохо: долгая транзакция
BEGIN;
SELECT * FROM huge_table;
-- ... долгие вычисления на приложении ...
COMMIT;  -- Спустя час!

-- За это время VACUUM не может удалить старые версии,
-- и таблица раздувается (bloat).
```

Проверить долгие транзакции:

```sql
SELECT 
  pid,
  usename,
  query_start,
  query,
  EXTRACT(EPOCH FROM (NOW() - query_start)) as seconds
FROM pg_stat_activity
WHERE query_start < NOW() - INTERVAL '5 minutes'
ORDER BY query_start;
```


## Вопросы для самопроверки
---

1. Что такое MVCC и почему PostgreSQL его использует вместо блокировок?
2. Объясни на примере, как создаются версии строк при UPDATE.
3. Что такое xmin и xmax? Как они определяют видимость строки?
4. Почему долгая открытая транзакция вредна для производительности?
5. Что такое bloat и как его предотвратить?

---

**[← Назад к PostgreSQL](../)**