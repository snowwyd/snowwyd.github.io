---
layout: default
title: Смещения и управление состоянием
permalink: /interview-prep/databases-cache/kafka/offsets/
---

# Цель
---
Смещение — это "закладка" в книге Kafka. Это показывает, где находится потребитель. Эта тема легче чем она выглядит, но она очень важна для production систем.


# Материалы
---
## Что такое смещение?
---

**Смещение** — это просто целое число, порядковый номер сообщения в разделе.

```
Раздел 0:
├─ Смещение 0: сообщение1
├─ Смещение 1: сообщение2
├─ Смещение 2: сообщение3
├─ Смещение 3: сообщение4
└─ Смещение 4: сообщение5
```

Потребитель отслеживает: "Я прочитал до смещения 2". В следующий раз, когда подключится, он начнет со смещения 3.

## Где хранятся смещения?
---

Смещения хранятся в специальной внутренней теме `__consumer_offsets`.

Это обычная Kafka тема, и каждая фиксирующая операция — это просто сообщение в эту тему.

**Структура сообщения**: `[идентификатор_группы, тема, раздел] → смещение`

Это значит:
- Разные группы потребителей могут хранить разные смещения для одной темы
- Смещения хранятся как сообщения (могут быть перемещены между брокерами и т.д.)

## Стратегии фиксирования смещений
---

### Автофиксирование (автоматическое)

```go
конфиг := kafka.ReaderConfig{
    Brokers:        []string{"localhost:9092"},
    Topic:          "заказы",
    GroupID:        "обработчики-заказов",
    CommitInterval: time.Second, // каждую секунду
}
reader := kafka.NewReader(конфиг)

for {
    сообщение, ошибка := reader.ReadMessage(ctx)
    // Kafka АВТОМАТИЧЕСКИ зафиксирует смещение после ReadMessage
    обработатьСообщение(сообщение)
}
```

**Плюсы**:
- Просто, не нужно думать
- Меньше кода

**Минусы**:
- **ПОТЕРЯ ДАННЫХ**: Если процесс упадет ДО завершения обработки сообщения, смещение уже зафиксировано. Другой потребитель пропустит это сообщение.
- Нет контроля над процессом

### Ручное фиксирование

```go
конфиг := kafka.ReaderConfig{
    Brokers:        []string{"localhost:9092"},
    Topic:          "заказы",
    GroupID:        "обработчики-заказов",
    CommitInterval: 0, // ОТКЛЮЧИТЬ автофиксирование
    StartOffset:    kafka.LastOffset,
}
reader := kafka.NewReader(конфиг)

for {
    сообщение, ошибка := reader.ReadMessage(ctx)
    if ошибка != nil {
        break
    }
    
    // Обрабатываем сообщение
    if ошибка := обработатьСообщение(сообщение); ошибка != nil {
        log.Printf("Ошибка обработки: %v", ошибка)
        continue
    }
    
    // ТОЛЬКО ПОТОМ фиксируем смещение
    if ошибка := reader.CommitMessages(ctx, сообщение); ошибка != nil {
        log.Printf("Ошибка фиксирования: %v", ошибка)
    }
}
```

**Плюсы**:
- Полный контроль
- Можем гарантировать обработку перед фиксированием
- Семантика "ровно один раз"

**Минусы**:
- Больше кода
- Нужно обрабатывать ошибки фиксирования

**На собеседовании**: 
> "Какую стратегию выбрать?"
> Ответ: "Зависит от важности данных. Для критичных (платежи, заказы) — ручное фиксирование. Для логирования/аналитики — автофиксирование."

## Поведение сброса смещений
---

Что если потребитель подключился впервые и не знает, откуда начать читать?

### auto.offset.reset

**earliest** (самый начало):
```go
reader := kafka.NewReader(kafka.ReaderConfig{
    Brokers:     []string{"localhost:9092"},
    Topic:       "заказы",
    GroupID:     "новая-группа",
    StartOffset: kafka.FirstOffset, // начни с самого начала
})
```
- Потребитель начнет с самого первого сообщения в теме
- Используйте для ново-запущенной системы, которая хочет обработать ВСЮ историю

**latest** (самый конец):
```go
reader := kafka.NewReader(kafka.ReaderConfig{
    Brokers:     []string{"localhost:9092"},
    Topic:       "заказы",
    GroupID:     "новая-группа",
    StartOffset: kafka.LastOffset, // начни с конца
})
```
- Потребитель начнет с новых сообщений (прошлые пропустит)
- Используйте для систем, которым нужны только новые события

**none** (ошибка):
- Если нет сохраненного смещения и auto.offset.reset=none, потребитель получит ошибку

## Ошибки фиксирования (Commit failures)
---

Что если фиксирование не сработало?

```go
сообщение, ошибка := reader.ReadMessage(ctx)
if ошибка != nil {
    break
}

обработатьСообщение(сообщение)

// Фиксирование не сработало
if ошибка := reader.CommitMessages(ctx, сообщение); ошибка != nil {
    // Что теперь?
    // Опция 1: Ignore и продолжить (потеря данных!)
    // Опция 2: Повторить фиксирование
    // Опция 3: Выйти из программы и разобраться
}
```

**Лучшая практика**: Повторить с экспоненциальной задержкой, или выйти из программы.

```go
повторов := 3
for i := 0; i < повторов; i++ {
    if ошибка := reader.CommitMessages(ctx, сообщение); ошибка == nil {
        break
    }
    if i < повторов-1 {
        time.Sleep(time.Duration(100*math.Pow(2, float64(i))) * time.Millisecond)
    } else {
        log.Fatal("Ошибка фиксирования смещения:", ошибка)
    }
}
```

## Типичные вопросы собеседования
---

**В: Потребитель прочитал сообщение, начал его обрабатывать, но процесс упал. Что будет?**
О: Зависит от стратегии фиксирования:
- Автофиксирование: Смещение уже было зафиксировано до обработки. Сообщение потеряется.
- Ручное фиксирование: Смещение не зафиксировано. Другой потребитель прочитает сообщение заново.

**В: Как мне переобработать все сообщения из темы?**
О: Создайте новую группу потребителей с auto.offset.reset=earliest. Она начнет с начала. ИЛИ используйте `kafka-consumer-groups` для сброса смещений существующей группы.

**В: Я вижу в `__consumer_offsets` много tombstones (нулевые значения). Что это?**
О: Tombstones используются для удаления старых фиксирований. Это нормально, Kafka сжимает эту тему со временем.

**В: Как я могу в production моментально переключить потребителя на конец темы без обработки истории?**
О: Создайте новую группу потребителей. Или используйте `kafka-consumer-groups --reset-offsets --to-latest`.

---

**[← Назад к Kafka](../)**