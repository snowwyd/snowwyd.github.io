---
layout: default
title: Архитектура Kafka
permalink: /interview-prep/databases-cache/kafka/architecture/
---
# Цель
---
Это фундаментальная тема, которую вы должны понимать идеально. На собеседовании вас обязательно спросят: "Объясни архитектуру Kafka". Давайте разберемся во всех деталях.

# Материалы
---
**Apache Kafka** — это распределённая система для обработки потоков событий в реальном времени. Если совсем просто: это помощник, который стоит между вашими микросервисами и передает сообщения от одного к другому, не давая им напрямую общаться друг с другом.

**Аналогия**: Представьте почтовую систему. Вместо того, чтобы сразу идти к другому человеку (прямой вызов), вы кладете письмо на почту (Kafka). Почта доставляет его когда смогла, и получатель может взять письмо, когда будет готов.

**Почему это важно?**
- **Развязка сервисов**: микросервисы не зависят друг от друга напрямую
- **Асинхронность**: события обрабатываются с задержкой, не блокируя производителя
- **Масштабируемость**: может обрабатывать миллионы сообщений в секунду
- **Надежность**: данные хранятся на диске, не теряются при сбоях

## Основные компоненты
---
### 1. Broker (Брокер)
**Broker** — это отдельный сервер Kafka. Обычно в production работает кластер из 3+ брокеров.

Брокер отвечает за:
- Сохранение сообщений на диск
- Передачу сообщений от производителей к потребителям
- Управление смещениями (позициями чтения)
- Репликацию данных

**Пример**: У вас есть кластер из 3 брокеров с IP адресами localhost:9092, localhost:9093, localhost:9094.

### 2. Topic (Тема)
**Topic** — это логическая категория или поток сообщений, к которому подписываются потребители и в который пишут производители.

Можно думать о теме как о канале в Telegram:
- Один topic для заказов: `заказы`
- Один topic для пользовательских событий: `события-пользователей`
- Один topic для платежей: `платежи`

Каждый topic имеет имя, по которому на него ссылаются.

### 3. Partition (Раздел)
**Partition** — это подразделение topic. Каждый topic может иметь много разделов. Это ключ к масштабируемости Kafka.

**Почему разделы нужны?**
- **Параллелизм**: разные потребители могут читать разные разделы одновременно
- **Масштабируемость**: данные распределяются между брокерами
- **Упорядочение**: сообщения в одном разделе сохраняют порядок

**Пример**: Topic `заказы` может иметь 5 разделов:
```
Topic: заказы
├─ Раздел 0
├─ Раздел 1
├─ Раздел 2
├─ Раздел 3
└─ Раздел 4
```

Когда производитель отправляет сообщение, Kafka решает в какой раздел его положить (обычно по ключу сообщения).

### 4. Producer (Производитель)
**Producer** — это приложение, которое отправляет сообщения в темы.

Производитель:
- Выбирает, в какой topic отправить сообщение
- Может указать ключ сообщения (определяет раздел)
- Может указать значение (сам payload)
- Обновляет метаданные о том, где найти лидера раздела

**Пример на Go**:
```go
writer := &kafka.Writer{
    Addr:  kafka.TCP("localhost:9092"),
    Topic: "заказы",
}
defer writer.Close()

// Отправка сообщения
err := writer.WriteMessages(ctx, kafka.Message{
    Key:   []byte("пользователь-123"),
    Value: []byte(`{"заказ_id": "12345", "сумма": 99.99}`),
})
```

### 5. Consumer (Потребитель)
**Consumer** — это приложение, которое читает сообщения из тем.

Потребитель:
- Подписывается на одну или несколько тем
- Может быть частью группы потребителей
- Отслеживает, какие сообщения уже прочитал (смещение)
- Может обрабатывать сообщения в реальном времени

**Пример на Go**:
```go
reader := kafka.NewReader(kafka.ReaderConfig{
    Brokers: []string{"localhost:9092"},
    Topic:   "заказы",
    GroupID: "обработчики-заказов",
})
defer reader.Close()

// Чтение сообщений
for {
    msg, err := reader.ReadMessage(ctx)
    if err != nil {
        break
    }
    обработатьЗаказ(msg.Value)
}
```

### 6. Consumer Group (Группа потребителей)
**Consumer Group** — это коллекция потребителей, которые работают вместе для обработки сообщений из одного или нескольких тем.

**Как это работает?**
- Каждое сообщение в теме доставляется только одному потребителю в группе
- Если у вас 5 разделов и 3 потребителя в группе, то сообщения распределяются между ними
- Если одного потребителя упало, его работу берут на себя другие (переназначение)

**Пример**:
```
Topic: заказы (5 разделов)
Группа потребителей: обработчики-заказов
├─ Потребитель 1 → читает Раздел 0, 1
├─ Потребитель 2 → читает Раздел 2, 3
└─ Потребитель 3 → читает Раздел 4
```

### 7. Offset (Смещение)
**Offset** — это уникальный ID сообщения в разделе. Это как закладка в книге: "я прочитал до сюда".

Каждое сообщение в разделе имеет порядковый номер:
```
Раздел 0:
├─ Смещение 0: {"пользователь_id": 1}
├─ Смещение 1: {"пользователь_id": 2}
├─ Смещение 2: {"пользователь_id": 3}
├─ Смещение 3: {"пользователь_id": 4}
└─ Смещение 4: {"пользователь_id": 5}
```

Потребитель отслеживает: "Я прочитал до смещения 3". Когда он подключится в следующий раз, он начнет со смещения 4.

### 8. Leader и Follower (Лидер и последователь)
Каждый раздел имеет:
- **Leader** — брокер, который обрабатывает все читаемые и записываемые запросы
- **Followers** — брокеры, которые реплицируют данные от лидера

Если лидер падает, один из followers становится новым лидером (это называется выборами лидера).

## Как все это работает вместе?
---
### Процесс отправки сообщения (Producer):

1. Производитель отправляет сообщение, указывая topic и возможно ключ
2. Сервис метаданных Kafka говорит производителю: "Лидер раздела 2 находится на брокере 1"
3. Производитель отправляет сообщение напрямую на брокер 1
4. Брокер 1 добавляет сообщение в раздел 2 и присваивает ему смещение
5. Брокер 1 реплицирует сообщение на followers
6. Производитель получает подтверждение о доставке (или ошибку)

### Процесс чтения сообщения (Consumer):

1. Потребитель говорит: "Я хочу читать из topic заказы, я часть группы обработчики-заказов"
2. Координатор Kafka назначает какие разделы прочитает этот потребитель
3. Потребитель говорит: "Дай мне сообщения со смещения 100 из раздела 0"
4. Брокер отправляет пакет сообщений
5. Потребитель их обрабатывает
6. Потребитель отправляет в Kafka: "Я обработал до смещения 105"

## Роль ZooKeeper
---
ZooKeeper — это сервис для координации в распределенной системе. Kafka использует его для:
- Выбора лидера (выборы лидера)
- Управления членством группы потребителей
- Хранения метаданных о темах и разделах
- Отслеживания состояния брокеров

**Примечание**: В новых версиях Kafka (3.0+) идет переход на KRaft (Kafka Raft) как замену ZooKeeper, но в большинстве компаний все еще используют ZooKeeper.

## Типичные вопросы собеседования
---
**В: Почему Kafka лучше, чем обычная база данных для событий?**
О: Kafka оптимизирована для последовательного чтения/записи (очень быстро), а БД оптимизирована для поиска по индексам. Kafka может обрабатывать миллионы событий в секунду.

**В: Что происходит если производитель отправляет сообщение, а лидер раздела падает?**
О: В зависимости от конфигурации acks: если acks=1, производитель может подумать, что сообщение обработано, но оно может потеряться. Если acks=all, производитель будет ждать, пока все синхронизированные replicas подтвердят.

**В: Может ли несколько потребителей читать из одного раздела?**
О: Нет, в одной группе потребителей только один потребитель может читать из раздела. Но можно создать несколько групп потребителей, и каждая будет читать все разделы независимо.

**В: Как масштабировать потребление?**
О: Добавьте больше потребителей в группу потребителей (до количества разделов). Каждый новый потребитель получит часть разделов и сможет читать параллельно.

---

**[← Назад к Kafka](../)**