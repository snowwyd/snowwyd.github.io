---
layout: default
title: Конкурентность - базовые примитивы
permalink: /interview-prep/go-deep-dive/concurrency/
---

# Цель
---
Ты уже знаешь, что такое горутины и каналы. Теперь нужно **действительно понять**, как они работают под капотом, какие проблемы они решают, и как их правильно использовать. Конкурентность — это ядро Go, и 90% ошибок разработчиков начинаются здесь.

# Зачем это нужно на собеседовании?
---
Тебя спросят:
- В чём разница между конкурентностью (concurrency) и параллелизмом (parallelism)?
- Как горутины работают под капотом?
- Что такое race condition и как её избежать?
- Когда использовать горутины, а когда нет?
- Как работают каналы и буферизованные каналы?

Если ты не можешь ответить на эти вопросы, интервьюер поймет, что у тебя есть data races в коде.

# Теория

### Конкурентность vs Параллелизм
---
**Это разные вещи!**

**Конкурентность (Concurrency):**
- Несколько задач **начинаются, приостанавливаются, продолжаются** в произвольном порядке
- На одном ядре процессора
- Вроде того, как один официант обслуживает несколько столиков (прерывисто)

```
Время  | Задача 1 | Задача 2 | Задача 3 |
1      |    ██    |          |          |
2      |          |    ██    |          |
3      |    ██    |          |          |
4      |          |          |    ██    |
```

**Параллелизм (Parallelism):**
- Несколько задач **выполняются одновременно** на разных ядрах
- На нескольких ядрах процессора
- Вроде того, как несколько официантов работают одновременно

```
Ядро 1 | Задача 1  ██ ██ ██ ██ ██
Ядро 2 | Задача 2  ██ ██ ██ ██ ██
Ядро 3 | Задача 3  ██ ██ ██ ██ ██
```

**Go достигает параллелизма через конкурентность!**

```go
// На компьютере с 4 ядрами, Go может запустить 1000 горутин
// Go планировщик сам распределит их между ядрами
```

### Горутины (Goroutines)
---
**Горутина** — это очень легкий "поток" (не путать с OS потоками!).

**Почему горутины отличаются от потоков:**
- Горутина весит ~2-4 КБ памяти
- OS поток весит ~1-2 МБ памяти
- Поэтому ты можешь запустить миллионы горутин, но только десятки потоков

**Как запустить горутину:**
```go
// Запускаем функцию в горутине через ключевое слово go
go myFunction()

// Запускаем анонимную функцию в горутине
go func() {
    fmt.Println("I'm running concurrently!")
}()

// Главная программа сразу продолжает работать!
```

**Проблема:** Главная горутина заканчивается, и программа умирает, не дожидаясь других горутин

```go
func main() {
    go func() {
        time.Sleep(1 * time.Second)
        fmt.Println("I will never be printed!")
    }()
    
    // Программа заканчивается сразу, не дождавшись горутины
}
```

**Решение: WaitGroup**
```go
import "sync"

func main() {
    var wg sync.WaitGroup
    
    // "Ожидаю 1 горутину"
    wg.Add(1)
    
    go func() {
        defer wg.Done()  // "Горутина закончилась"
        
        time.Sleep(1 * time.Second)
        fmt.Println("Now I will be printed!")
    }()
    
    wg.Wait()  // Ждём, пока все горутины закончатся
    fmt.Println("Main finished")
}
```

### Race Condition (гонка данных)
---
**Гонка данных** происходит, когда несколько горутин одновременно обращаются к одним и тем же данным, и **хотя бы одна из них их изменяет**.

**Классический пример - счётчик:**
```go
var counter int

go func() {
    for i := 0; i < 1000; i++ {
        counter++  // Читаем counter, увеличиваем, записываем
    }
}()

go func() {
    for i := 0; i < 1000; i++ {
        counter++  // В то же время!
    }
}()

// counter должен быть 2000, но из-за гонки может быть 1234, 1500, 1876...
```

**Почему это происходит?**
Операция `counter++` — это не одна операция! Это три:
1. Прочитать значение counter (пусть 42)
2. Увеличить его (получить 43)
3. Записать обратно

```
Горутина 1           | Горутина 2          | counter
                     |                     | 0
Прочитать 0          |                     | 0
                     | Прочитать 0         | 0
Увеличить, получил 1 |                     | 0
                     | Увеличить, получил 1| 0
Записать 1           |                     | 1
                     | Записать 1          | 1
```

Обе горутины прочитали 0 и записали 1, вместо того чтобы записать 1 и 2!

**Как найти гонку?**
```bash
go run -race main.go
```

Go автоматически обнаружит гонки данных!

**Как её избежать?**

#### Способ 1: Мьютекс (Mutex)
```go
var counter int
var mu sync.Mutex  // Мьютекс - "охранник"

go func() {
    for i := 0; i < 1000; i++ {
        mu.Lock()       // Захватываем охранника
        counter++
        mu.Unlock()     // Отпускаем охранника
    }
}()

go func() {
    for i := 0; i < 1000; i++ {
        mu.Lock()
        counter++
        mu.Unlock()
    }
}()

// Теперь только одна горутина может работать с counter за раз
```

#### Способ 2: Каналы (нижу подробнее)
#### Способ 3: Atomic операции
```go
var counter int64

go func() {
    for i := 0; i < 1000; i++ {
        atomic.AddInt64(&counter, 1)  // Атомарная операция
    }
}()
```

### Каналы (Channels)
---
**Канал** — это "труба" для безопасной передачи данных между горутинами.

```go
// Создаём канал для передачи int
ch := make(chan int)

// Горутина отправляет в канал
go func() {
    ch <- 42  // <- означает "отправить"
}()

// Главная горутина получает из канала
value := <-ch  // <- означает "получить"
fmt.Println(value)  // 42
```

**Главное:** Канал **блокирует** отправителя и получателя!

```go
ch := make(chan int)

// Эта линия заблокирует горутину, пока кто-то не получит из канала
ch <- 42

// Нужна другая горутина, которая получит
go func() {
    value := <-ch
    fmt.Println(value)  // 42
}()
```

**Закрытие канала:**
```go
ch := make(chan int)

go func() {
    ch <- 1
    ch <- 2
    ch <- 3
    close(ch)  // Закрываем канал
}()

// Получаем все значения
for value := range ch {
    fmt.Println(value)  // 1, 2, 3
}
```

### Буферизованные каналы
---
По умолчанию каналы **небуферизованные** — отправитель блокируется сразу.

```go
ch := make(chan int)  // Небуферизованный

ch <- 1  // Блокируется, пока нет получателя
```

С буфером канал может хранить несколько значений:

```go
ch := make(chan int, 3)  // Буфер на 3 значения

ch <- 1  // OK, буфер пустой
ch <- 2  // OK, есть место
ch <- 3  // OK, буфер полный
ch <- 4  // Блокируется! Буфер переполнен

value := <-ch  // Получаем 1
ch <- 4  // OK, теперь есть место
```

**Когда использовать буфер?**
```go
// Без буфера: горутина блокируется
results := make(chan int)  // ❌ Может заблокировать
go sendResults(results)

// С буфером: горутина может отправить и уйти
results := make(chan int, 100)  // ✅ Не заблокирует
go sendResults(results)
```

### Select (выбор между каналами)
---
`Select` позволяет ждать от **нескольких каналов одновременно**.

```go
ch1 := make(chan string)
ch2 := make(chan string)

go func() {
    time.Sleep(1 * time.Second)
    ch1 <- "Result from channel 1"
}()

go func() {
    time.Sleep(2 * time.Second)
    ch2 <- "Result from channel 2"
}()

// Получим результат из того канала, который первым ответит
select {
case result := <-ch1:
    fmt.Println(result)  // Выполнится через 1 сек
case result := <-ch2:
    fmt.Println(result)
}
```

**С timeout:**
```go
select {
case result := <-ch:
    fmt.Println("Got result:", result)
case <-time.After(1 * time.Second):
    fmt.Println("Timeout!")
}
```

## Практический пример: обработка нескольких запросов

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func processRequest(id int, results chan string) {
    time.Sleep(time.Duration(id) * 100 * time.Millisecond)
    results <- fmt.Sprintf("Request %d processed", id)
}

func main() {
    results := make(chan string, 5)
    var wg sync.WaitGroup
    
    // Запускаем 5 горутин
    for i := 1; i <= 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            processRequest(id, results)
        }(i)
    }
    
    // Закрываем канал, когда все горутины закончатся
    go func() {
        wg.Wait()
        close(results)
    }()
    
    // Получаем все результаты
    for result := range results {
        fmt.Println(result)
    }
}
```

# Правило для собеседования
---
**Когда спрашивают про конкурентность, отвечай:**

"Конкурентность в Go достигается через горутины — очень легкие 'потоки', которые весят килобайты, а не мегабайты. Я использую горутины, когда нужно выполнить несколько задач одновременно.

Главная проблема — гонки данных (race conditions). Я избегаю их, используя каналы для передачи данных между горутинами или мьютексы для защиты общей памяти.

Каналы — это основной способ общения между горутинами в Go. Я использую select для ожидания от нескольких каналов, и WaitGroup для ожидания завершения горутин.

Всегда проверяю код с флагом `-race`, чтобы обнаружить гонки."

---

**[← Назад к Go углубленно](../)**
