---
layout: default
title: Планировщик и Garbage Collector
permalink: /interview-prep/go-deep-dive/sched-gc
---

# Цель
---
Понять, как Go на самом деле распределяет горутины между процессорными ядрами, как работает Garbage Collector (GC), и почему иногда код "зависает" на миллисекунду. Это знание позволит тебе писать высокопроизводительный код и диагностировать проблемы.

# Зачем это нужно на собеседовании?
---
Тебя спросят:
- Как планировщик Go распределяет горутины?
- Что такое M, P, G в контексте планировщика?
- Как работает GC в Go?
- Почему GC может замораживать программу?
- Как оптимизировать код для снижения GC паузы?

Ответ покажет, что ты разбираешься в performance.

# Теория

### Планировщик Go (M:P:G)
---
Go использует **собственный планировщик**, который управляет горутинами на уровне приложения.

**Три ключевых компонента:**

```
M = OSThread (поток операционной системы)
P = Processor (логический процессор, как ядро для Go)
G = Goroutine (горутина)
```

**Визуально:**
```
┌─────────────────────────────────────┐
│ Go Program (1000 горутин)           │
│                                     │
│ ┌─────────────────────────────────┐ │
│ │ P1 (Ядро 1)                     │ │
│ │ ┌──────┐ ┌──────┐ ┌──────┐     │ │
│ │ │ G1   │ │ G2   │ │ G3   │ ... │ │
│ │ │ (⚙)  │ │      │ │      │     │ │
│ │ └──────┘ └──────┘ └──────┘     │ │
│ │                                 │ │
│ └─────────────────────────────────┘ │
│ ┌─────────────────────────────────┐ │
│ │ P2 (Ядро 2)                     │ │
│ │ ┌──────┐ ┌──────┐               │ │
│ │ │ G100 │ │ G101 │ ...           │ │
│ │ │ (⚙)  │ │      │               │ │
│ │ └──────┘ └──────┘               │ │
│ │                                 │ │
│ └─────────────────────────────────┘ │
│              ...                    │
└─────────────────────────────────────┘
```

**Как это работает:**
1. Каждый P имеет **очередь (run queue)** с горутинами
2. Каждый M (OS поток) подчиняется одному P
3. Go планировщик выбирает, какую G запустить на M

```go
// Настройка количества логических процессоров
import "runtime"

// Сколько P может использовать Go?
numP := runtime.NumCPU()  // Количество ядер

// Можешь изменить
runtime.GOMAXPROCS(4)  // Используй максимум 4 ядра
```

**Вытеснение (Preemption):**
Go планировщик может **прерывать** горутину в середине выполнения!

```go
func heavyWork() {
    for i := 0; i < 1000000; i++ {
        // После каждого 10 мс Go может прерывать горутину
        // (примерно, не точно)
    }
}
```

Благодаря этому, одна долгая горутина не "повесит" все остальные.

### Когда горутина переходит на другой M?
---
1. **Blocking системные вызовы** (file I/O, network)
   ```go
   // Go видит, что это будет долгое ожидание (блокировка)
   // Создает новый M и запускает другую горутину
   data, _ := ioutil.ReadFile("file.txt")  // Горутина блокируется
   ```

2. **Явное переключение**
   ```go
   // Go может переключиться на другую горутину
   runtime.Gosched()
   ```

### Garbage Collector (GC)
---
**GC** — это механизм, который автоматически освобождает неиспользуемую память.

**Без GC (как в C):**
```c
int* ptr = malloc(sizeof(int) * 100);
// Используем ptr
free(ptr);  // ОБЯЗАТЕЛЬНО освобождаем, иначе утечка памяти!
```

**С GC (как в Go):**
```go
ptr := make([]int, 100)
// Используем ptr
// GC сам поймет, что это больше не нужно, и освободит
```

**Как работает GC в Go:**

1. **Mark phase (фаза маркировки)**
   - GC проходит по всем живым объектам и помечает их как "используемые"
   - Всё, что не помечено — мёртвые объекты

2. **Sweep phase (фаза чистки)**
   - GC удаляет все немеченые объекты
   - Память освобождается

**Проблема:** Во время GC, весь код СТОП! (Stop The World)

```
Время  | Твой код       | GC      | Твой код
1-100  | ⚙⚙⚙⚙⚙⚙⚙⚙⚙⚙  |         | ⚙⚙⚙⚙⚙⚙⚙
100    |                | ⏹️ STOP |
101    |                | Mark...  |
102    |                | Mark...  |
103    |                | Sweep... |
104    |                | Done ✓   |
105+   | ⚙⚙⚙⚙⚙⚙⚙⚙⚙⚙  |         | ⚙⚙⚙⚙⚙⚙⚙
```

**Когда срабатывает GC?**
```go
// GC срабатывает, когда:
// 1. Память выделена в 2 раза больше, чем в прошлый раз
// 2. Прошло более 2 минут с последнего GC
// 3. Ты явно вызвал

runtime.GC()  // Явно запустить GC
```

### Проблемы GC и как их избежать
---

#### Проблема 1: GC паузы
```
Без оптимизации: 100ms пауза
С оптимизацией:  10ms пауза
```

**Как минимизировать:**

1. **Меньше аллокаций на heap**
   ```go
   // ❌ Плохо: на каждой итерации выделяется новая память
   for i := 0; i < 1000000; i++ {
       slice := make([]int, 100)
       process(slice)
   }
   
   // ✅ Хорошо: переиспользуем один slice
   slice := make([]int, 100)
   for i := 0; i < 1000000; i++ {
       process(slice)
   }
   ```

2. **Используй object pools**
   ```go
   // Переиспользуем объекты, не создавая новые
   var pool sync.Pool
   
   func getBuffer() []byte {
       if b := pool.Get(); b != nil {
           return b.([]byte)
       }
       return make([]byte, 1024)
   }
   
   func putBuffer(b []byte) {
       pool.Put(b)
   }
   ```

3. **Убедись, что объект не на heap без причины**
   ```go
   // ❌ На heap
   func getData() *[]int {
       return &[]int{1, 2, 3}
   }
   
   // ✅ На stack
   func getData() [3]int {
       return [3]int{1, 2, 3}
   }
   ```

#### Проблема 2: Memory leak (утечка памяти)
Go автоматически освобождает память, но ты все ещё можешь создать утечку!

```go
// ❌ Утечка: горутина не заканчивается, удерживает память
func startWorker() {
    go func() {
        for {  // Бесконечный цикл!
            time.Sleep(time.Second)
        }
    }()
    // Горутина никогда не заканчивается
}

// ✅ Хорошо: горутина заканчивается нормально
func startWorker(ctx context.Context) {
    go func() {
        for {
            select {
            case <-ctx.Done():
                return
            default:
                time.Sleep(time.Second)
            }
        }
    }()
}
```

### Мониторинг GC
---

**Посмотреть статистику GC:**
```go
import (
    "fmt"
    "runtime"
)

var m runtime.MemStats
runtime.ReadMemStats(&m)

fmt.Printf("Alloc = %v MB", m.Alloc / 1024 / 1024)
fmt.Printf("GC runs = %v", m.NumGC)
fmt.Printf("GC pause = %v ns", m.PauseNs[(m.NumGC+255)%256])
```

**Запустить с логированием GC:**
```bash
GODEBUG=gctrace=1 go run main.go
```

**Output:**
```
gc 1 @0.010s 0%: 0.012+0.047+0.005 ms clock, 0.048+0.000+0.000/0.036/0.000 ms cpu
```

## Практический пример: профилирование GC

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func main() {
    // Снимаем памяти ДО
    var m1 runtime.MemStats
    runtime.ReadMemStats(&m1)
    
    // Делаем много аллокаций
    var slices [][]int
    for i := 0; i < 1000; i++ {
        slices = append(slices, make([]int, 1000))
    }
    
    // Снимаем памяти ПОСЛЕ
    var m2 runtime.MemStats
    runtime.ReadMemStats(&m2)
    
    fmt.Printf("Before GC: %d MB\n", m1.Alloc/1024/1024)
    fmt.Printf("After alloc: %d MB\n", m2.Alloc/1024/1024)
    fmt.Printf("GC runs before: %d\n", m1.NumGC)
    fmt.Printf("GC runs after: %d\n", m2.NumGC)
    
    // Очищаем
    slices = nil
    
    // Явно вызываем GC
    runtime.GC()
    time.Sleep(100 * time.Millisecond)
    
    // Снимаем памяти ПОСЛЕ GC
    var m3 runtime.MemStats
    runtime.ReadMemStats(&m3)
    
    fmt.Printf("After GC: %d MB\n", m3.Alloc/1024/1024)
    fmt.Printf("GC runs after: %d\n", m3.NumGC)
}
```

# Правило для собеседования
---
**Когда спрашивают про планировщик, отвечай:**

"Go планировщик управляет горутинами на уровне приложения. Каждый логический процессор (P) имеет очередь горутин, и каждый OS поток (M) выбирает горутину из этой очереди. Go может переключаться между горутинами, особенно когда одна блокируется на I/O.

GC в Go работает автоматически и освобождает память, которую ты больше не используешь. Однако GC может создавать паузы (Stop The World). Чтобы минимизировать это, я стараюсь:
1. Сокращать количество аллокаций
2. Переиспользовать объекты (object pools)
3. Не создавать утечек памяти через горутины

Я регулярно профилирую код, чтобы найти утечки и горячие точки."

---

**[← Назад к Go углубленно](../)**
